// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package revoltgo

import (
	"time"

	"github.com/tinylib/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z Account) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "_id"
	o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "email"
	o = append(o, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Email)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Account) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "email":
			z.Email, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Email")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Account) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Email)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AccountChangeEmailData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "email"
	o = append(o, 0x82, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Email)
	// string "current_password"
	o = append(o, 0xb0, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.CurrentPassword)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountChangeEmailData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			z.Email, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Email")
				return
			}
		case "current_password":
			z.CurrentPassword, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentPassword")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AccountChangeEmailData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Email) + 17 + msgp.StringPrefixSize + len(z.CurrentPassword)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AccountChangePasswordData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "password"
	o = append(o, 0x82, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	// string "current_password"
	o = append(o, 0xb0, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.CurrentPassword)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountChangePasswordData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		case "current_password":
			z.CurrentPassword, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentPassword")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AccountChangePasswordData) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Password) + 17 + msgp.StringPrefixSize + len(z.CurrentPassword)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AccountCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "email"
	o = append(o, 0x84, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Email)
	// string "password"
	o = append(o, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	// string "invite"
	o = append(o, 0xa6, 0x69, 0x6e, 0x76, 0x69, 0x74, 0x65)
	o = msgp.AppendString(o, z.Invite)
	// string "captcha"
	o = append(o, 0xa7, 0x63, 0x61, 0x70, 0x74, 0x63, 0x68, 0x61)
	o = msgp.AppendString(o, z.Captcha)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			z.Email, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Email")
				return
			}
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		case "invite":
			z.Invite, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Invite")
				return
			}
		case "captcha":
			z.Captcha, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Captcha")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AccountCreateData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Email) + 9 + msgp.StringPrefixSize + len(z.Password) + 7 + msgp.StringPrefixSize + len(z.Invite) + 8 + msgp.StringPrefixSize + len(z.Captcha)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AccountDeleteConfirmData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "token"
	o = append(o, 0x81, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountDeleteConfirmData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AccountDeleteConfirmData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Token)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AccountReverifyData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "email"
	o = append(o, 0x82, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Email)
	// string "captcha"
	o = append(o, 0xa7, 0x63, 0x61, 0x70, 0x74, 0x63, 0x68, 0x61)
	o = msgp.AppendString(o, z.Captcha)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountReverifyData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			z.Email, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Email")
				return
			}
		case "captcha":
			z.Captcha, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Captcha")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AccountReverifyData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Email) + 8 + msgp.StringPrefixSize + len(z.Captcha)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Attachment) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "_id"
	o = append(o, 0x8c, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "tag"
	o = append(o, 0xa3, 0x74, 0x61, 0x67)
	o = msgp.AppendString(o, z.Tag)
	// string "filename"
	o = append(o, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Filename)
	// string "metadata"
	o = append(o, 0xa8, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61)
	if z.Metadata == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Metadata.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Metadata")
			return
		}
	}
	// string "content_type"
	o = append(o, 0xac, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ContentType)
	// string "size"
	o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Size)
	// string "deleted"
	o = append(o, 0xa7, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Deleted)
	// string "reported"
	o = append(o, 0xa8, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Reported)
	// string "message_id"
	o = append(o, 0xaa, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.MessageID)
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "server_id"
	o = append(o, 0xa9, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ServerID)
	// string "object_id"
	o = append(o, 0xa9, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ObjectID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Attachment) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "tag":
			z.Tag, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tag")
				return
			}
		case "filename":
			z.Filename, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filename")
				return
			}
		case "metadata":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Metadata = nil
			} else {
				if z.Metadata == nil {
					z.Metadata = new(AttachmentMetadata)
				}
				bts, err = z.Metadata.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Metadata")
					return
				}
			}
		case "content_type":
			z.ContentType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContentType")
				return
			}
		case "size":
			z.Size, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "deleted":
			z.Deleted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Deleted")
				return
			}
		case "reported":
			z.Reported, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reported")
				return
			}
		case "message_id":
			z.MessageID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MessageID")
				return
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "server_id":
			z.ServerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ServerID")
				return
			}
		case "object_id":
			z.ObjectID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Attachment) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 4 + msgp.StringPrefixSize + len(z.Tag) + 9 + msgp.StringPrefixSize + len(z.Filename) + 9
	if z.Metadata == nil {
		s += msgp.NilSize
	} else {
		s += z.Metadata.Msgsize()
	}
	s += 13 + msgp.StringPrefixSize + len(z.ContentType) + 5 + msgp.IntSize + 8 + msgp.BoolSize + 9 + msgp.BoolSize + 11 + msgp.StringPrefixSize + len(z.MessageID) + 8 + msgp.StringPrefixSize + len(z.UserID) + 10 + msgp.StringPrefixSize + len(z.ServerID) + 10 + msgp.StringPrefixSize + len(z.ObjectID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AttachmentMetadata) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "width"
	o = append(o, 0xa5, 0x77, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "height"
	o = append(o, 0xa6, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AttachmentMetadata) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = AttachmentMetadataType(zb0002)
			}
		case "width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AttachmentMetadata) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 6 + msgp.IntSize + 7 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AttachmentMetadataType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AttachmentMetadataType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = AttachmentMetadataType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AttachmentMetadataType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AuthMFAData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "password"
	o = append(o, 0x83, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	// string "recovery_code"
	o = append(o, 0xad, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.RecoveryCode)
	// string "totp_code"
	o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x70, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.TOTPCode)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthMFAData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		case "recovery_code":
			z.RecoveryCode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecoveryCode")
				return
			}
		case "totp_code":
			z.TOTPCode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TOTPCode")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AuthMFAData) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Password) + 14 + msgp.StringPrefixSize + len(z.RecoveryCode) + 10 + msgp.StringPrefixSize + len(z.TOTPCode)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AuthMFAMethod) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthMFAMethod) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = AuthMFAMethod(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AuthMFAMethod) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AuthMFAResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "email_otp"
	o = append(o, 0x86, 0xa9, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x6f, 0x74, 0x70)
	o = msgp.AppendBool(o, z.EmailOtp)
	// string "trusted_handover"
	o = append(o, 0xb0, 0x74, 0x72, 0x75, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6f, 0x76, 0x65, 0x72)
	o = msgp.AppendBool(o, z.TrustedHandover)
	// string "email_mfa"
	o = append(o, 0xa9, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x6d, 0x66, 0x61)
	o = msgp.AppendBool(o, z.EmailMfa)
	// string "totp_mfa"
	o = append(o, 0xa8, 0x74, 0x6f, 0x74, 0x70, 0x5f, 0x6d, 0x66, 0x61)
	o = msgp.AppendBool(o, z.TotpMfa)
	// string "security_key_mfa"
	o = append(o, 0xb0, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x6d, 0x66, 0x61)
	o = msgp.AppendBool(o, z.SecurityKeyMfa)
	// string "recovery_active"
	o = append(o, 0xaf, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
	o = msgp.AppendBool(o, z.RecoveryActive)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthMFAResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email_otp":
			z.EmailOtp, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EmailOtp")
				return
			}
		case "trusted_handover":
			z.TrustedHandover, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TrustedHandover")
				return
			}
		case "email_mfa":
			z.EmailMfa, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EmailMfa")
				return
			}
		case "totp_mfa":
			z.TotpMfa, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotpMfa")
				return
			}
		case "security_key_mfa":
			z.SecurityKeyMfa, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SecurityKeyMfa")
				return
			}
		case "recovery_active":
			z.RecoveryActive, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecoveryActive")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AuthMFAResponse) Msgsize() (s int) {
	s = 1 + 10 + msgp.BoolSize + 17 + msgp.BoolSize + 10 + msgp.BoolSize + 9 + msgp.BoolSize + 17 + msgp.BoolSize + 16 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AuthMFATOTPSecretResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "secret"
	o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.Secret)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthMFATOTPSecretResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AuthMFATOTPSecretResponse) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Secret)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AuthMFATicketResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "MFATicket"
	o = append(o, 0x81, 0xa9, 0x4d, 0x46, 0x41, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74)
	o, err = z.MFATicket.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MFATicket")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthMFATicketResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MFATicket":
			bts, err = z.MFATicket.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MFATicket")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AuthMFATicketResponse) Msgsize() (s int) {
	s = 1 + 10 + z.MFATicket.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AuthType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = AuthType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AuthType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bot) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "_id"
	o = append(o, 0x8a, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	// string "public"
	o = append(o, 0xa6, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63)
	o = msgp.AppendBool(o, z.Public)
	// string "analytics"
	o = append(o, 0xa9, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73)
	o = msgp.AppendBool(o, z.Analytics)
	// string "discoverable"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Discoverable)
	// string "interactions_url"
	o = append(o, 0xb0, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.InteractionsURL)
	// string "terms_of_service_url"
	o = append(o, 0xb4, 0x74, 0x65, 0x72, 0x6d, 0x73, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.TermsOfServiceURL)
	// string "privacy_policy_url"
	o = append(o, 0xb2, 0x70, 0x72, 0x69, 0x76, 0x61, 0x63, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.PrivacyPolicyURL)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendInt(o, z.Flags)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bot) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "public":
			z.Public, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Public")
				return
			}
		case "analytics":
			z.Analytics, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Analytics")
				return
			}
		case "discoverable":
			z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		case "interactions_url":
			z.InteractionsURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InteractionsURL")
				return
			}
		case "terms_of_service_url":
			z.TermsOfServiceURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TermsOfServiceURL")
				return
			}
		case "privacy_policy_url":
			z.PrivacyPolicyURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PrivacyPolicyURL")
				return
			}
		case "flags":
			z.Flags, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bot) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Owner) + 6 + msgp.StringPrefixSize + len(z.Token) + 7 + msgp.BoolSize + 10 + msgp.BoolSize + 13 + msgp.BoolSize + 17 + msgp.StringPrefixSize + len(z.InteractionsURL) + 21 + msgp.StringPrefixSize + len(z.TermsOfServiceURL) + 19 + msgp.StringPrefixSize + len(z.PrivacyPolicyURL) + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BotCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "name"
	o = append(o, 0x81, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BotCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BotCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BotEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "public"
	o = append(o, 0xa6, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63)
	o = msgp.AppendBool(o, z.Public)
	// string "analytics"
	o = append(o, 0xa9, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73)
	o = msgp.AppendBool(o, z.Analytics)
	// string "interactions_url"
	o = append(o, 0xb0, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.InteractionsURL)
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BotEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "public":
			z.Public, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Public")
				return
			}
		case "analytics":
			z.Analytics, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Analytics")
				return
			}
		case "interactions_url":
			z.InteractionsURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InteractionsURL")
				return
			}
		case "remove":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0002) {
				z.Remove = (z.Remove)[:zb0002]
			} else {
				z.Remove = make([]string, zb0002)
			}
			for za0001 := range z.Remove {
				z.Remove[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BotEditData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.BoolSize + 10 + msgp.BoolSize + 17 + msgp.StringPrefixSize + len(z.InteractionsURL) + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BotInformation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "owner"
	o = append(o, 0x81, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BotInformation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BotInformation) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Owner)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BotInviteData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "server"
	o = append(o, 0x82, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.Server)
	// string "group"
	o = append(o, 0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.Group)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BotInviteData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "server":
			z.Server, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Server")
				return
			}
		case "group":
			z.Group, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BotInviteData) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Server) + 6 + msgp.StringPrefixSize + len(z.Group)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChangeEmail) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ticket"
	o = append(o, 0x81, 0xa6, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74)
	o, err = z.Ticket.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Ticket")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChangeEmail) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ticket":
			bts, err = z.Ticket.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ticket")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChangeEmail) Msgsize() (s int) {
	s = 1 + 7 + z.Ticket.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Channel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 15
	// string "_id"
	o = append(o, 0x8f, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_type"
	o = append(o, 0xac, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.ChannelType))
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if z.Description == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Description)
	}
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if z.Icon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Icon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Icon")
			return
		}
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	// string "active"
	o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
	o = msgp.AppendBool(o, z.Active)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	if z.Server == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Server)
	}
	// string "voice"
	o = append(o, 0xa5, 0x76, 0x6f, 0x69, 0x63, 0x65)
	if z.Voice == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "max_users"
		o = append(o, 0x81, 0xa9, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73)
		if z.Voice.MaxUsers == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Voice.MaxUsers)
		}
	}
	// string "role_permissions"
	o = append(o, 0xb0, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.RolePermissions)))
	for za0001, za0002 := range z.RolePermissions {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, za0002.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, za0002.Deny)
	}
	// string "recipients"
	o = append(o, 0xaa, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Recipients)))
	for za0003 := range z.Recipients {
		o = msgp.AppendString(o, z.Recipients[za0003])
	}
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.Permissions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Permissions)
	}
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "last_message_id"
	o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64)
	if z.LastMessageID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.LastMessageID)
	}
	// string "default_permissions"
	o = append(o, 0xb3, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.DefaultPermissions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Deny)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Channel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChannelType")
					return
				}
				z.ChannelType = ChannelType(zb0002)
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Description = nil
			} else {
				if z.Description == nil {
					z.Description = new(string)
				}
				*z.Description, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Description")
					return
				}
			}
		case "icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Icon = nil
			} else {
				if z.Icon == nil {
					z.Icon = new(Attachment)
				}
				bts, err = z.Icon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Icon")
					return
				}
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		case "active":
			z.Active, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		case "server":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Server = nil
			} else {
				if z.Server == nil {
					z.Server = new(string)
				}
				*z.Server, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Server")
					return
				}
			}
		case "voice":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Voice = nil
			} else {
				if z.Voice == nil {
					z.Voice = new(ChannelVoiceInformation)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Voice")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Voice")
						return
					}
					switch msgp.UnsafeString(field) {
					case "max_users":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Voice.MaxUsers = nil
						} else {
							if z.Voice.MaxUsers == nil {
								z.Voice.MaxUsers = new(int)
							}
							*z.Voice.MaxUsers, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Voice", "MaxUsers")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Voice")
							return
						}
					}
				}
			}
		case "role_permissions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RolePermissions")
				return
			}
			if z.RolePermissions == nil {
				z.RolePermissions = make(map[string]PermissionOverwrite, zb0004)
			} else if len(z.RolePermissions) > 0 {
				clear(z.RolePermissions)
			}
			for zb0004 > 0 {
				var za0002 PermissionOverwrite
				zb0004--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions", za0001)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "RolePermissions", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						za0002.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Allow")
							return
						}
					case "d":
						za0002.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001)
							return
						}
					}
				}
				z.RolePermissions[za0001] = za0002
			}
		case "recipients":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recipients")
				return
			}
			if cap(z.Recipients) >= int(zb0006) {
				z.Recipients = (z.Recipients)[:zb0006]
			} else {
				z.Recipients = make([]string, zb0006)
			}
			for za0003 := range z.Recipients {
				z.Recipients[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Recipients", za0003)
					return
				}
			}
		case "permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Permissions = nil
			} else {
				if z.Permissions == nil {
					z.Permissions = new(int64)
				}
				*z.Permissions, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "last_message_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastMessageID = nil
			} else {
				if z.LastMessageID == nil {
					z.LastMessageID = new(string)
				}
				*z.LastMessageID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMessageID")
					return
				}
			}
		case "default_permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DefaultPermissions = nil
			} else {
				if z.DefaultPermissions == nil {
					z.DefaultPermissions = new(PermissionOverwrite)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DefaultPermissions")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "DefaultPermissions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						z.DefaultPermissions.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Allow")
							return
						}
					case "d":
						z.DefaultPermissions.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Channel) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 13 + msgp.StringPrefixSize + len(string(z.ChannelType)) + 5 + msgp.StringPrefixSize + len(z.Name) + 12
	if z.Description == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Description)
	}
	s += 5
	if z.Icon == nil {
		s += msgp.NilSize
	} else {
		s += z.Icon.Msgsize()
	}
	s += 5 + msgp.BoolSize + 7 + msgp.BoolSize + 7
	if z.Server == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Server)
	}
	s += 6
	if z.Voice == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10
		if z.Voice.MaxUsers == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	s += 17 + msgp.MapHeaderSize
	if z.RolePermissions != nil {
		for za0001, za0002 := range z.RolePermissions {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for za0003 := range z.Recipients {
		s += msgp.StringPrefixSize + len(z.Recipients[za0003])
	}
	s += 12
	if z.Permissions == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 6 + msgp.StringPrefixSize + len(z.Owner) + 16
	if z.LastMessageID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LastMessageID)
	}
	s += 20
	if z.DefaultPermissions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "name"
	o = append(o, 0x87, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	// string "archived"
	o = append(o, 0xa8, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Archived)
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		case "archived":
			z.Archived, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Archived")
				return
			}
		case "remove":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0002) {
				z.Remove = (z.Remove)[:zb0002]
			} else {
				z.Remove = make([]string, zb0002)
			}
			for za0001 := range z.Remove {
				z.Remove[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelEditData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 6 + msgp.StringPrefixSize + len(z.Owner) + 5 + msgp.StringPrefixSize + len(z.Icon) + 5 + msgp.BoolSize + 9 + msgp.BoolSize + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelFetchedMessages) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "messages"
	o = append(o, 0x83, 0xa8, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Messages)))
	for za0001 := range z.Messages {
		if z.Messages[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Messages[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Messages", za0001)
				return
			}
		}
	}
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0002)
				return
			}
		}
	}
	// string "members"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0003 := range z.Members {
		if z.Members[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Members[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Members", za0003)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelFetchedMessages) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "messages":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Messages")
				return
			}
			if cap(z.Messages) >= int(zb0002) {
				z.Messages = (z.Messages)[:zb0002]
			} else {
				z.Messages = make([]*Message, zb0002)
			}
			for za0001 := range z.Messages {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Messages[za0001] = nil
				} else {
					if z.Messages[za0001] == nil {
						z.Messages[za0001] = new(Message)
					}
					bts, err = z.Messages[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Messages", za0001)
						return
					}
				}
			}
		case "users":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0003) {
				z.Users = (z.Users)[:zb0003]
			} else {
				z.Users = make([]*User, zb0003)
			}
			for za0002 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0002] = nil
				} else {
					if z.Users[za0002] == nil {
						z.Users[za0002] = new(User)
					}
					bts, err = z.Users[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0002)
						return
					}
				}
			}
		case "members":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0004) {
				z.Members = (z.Members)[:zb0004]
			} else {
				z.Members = make([]*ServerMember, zb0004)
			}
			for za0003 := range z.Members {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Members[za0003] = nil
				} else {
					if z.Members[za0003] == nil {
						z.Members[za0003] = new(ServerMember)
					}
					bts, err = z.Members[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Members", za0003)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelFetchedMessages) Msgsize() (s int) {
	s = 1 + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Messages {
		if z.Messages[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Messages[za0001].Msgsize()
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0002].Msgsize()
		}
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0003 := range z.Members {
		if z.Members[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += z.Members[za0003].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ChannelJoinCall) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "token"
	o = append(o, 0x82, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	// string "url"
	o = append(o, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelJoinCall) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ChannelJoinCall) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Token) + 4 + msgp.StringPrefixSize + len(z.URL)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelJoinCallData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "node"
	o = append(o, 0x83, 0xa4, 0x6e, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Node)
	// string "force_disconnect"
	o = append(o, 0xb0, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x5f, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74)
	o = msgp.AppendBool(o, z.ForceDisconnect)
	// string "recipients"
	o = append(o, 0xaa, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Recipients)))
	for za0001 := range z.Recipients {
		o = msgp.AppendString(o, z.Recipients[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelJoinCallData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "node":
			z.Node, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Node")
				return
			}
		case "force_disconnect":
			z.ForceDisconnect, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ForceDisconnect")
				return
			}
		case "recipients":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recipients")
				return
			}
			if cap(z.Recipients) >= int(zb0002) {
				z.Recipients = (z.Recipients)[:zb0002]
			} else {
				z.Recipients = make([]string, zb0002)
			}
			for za0001 := range z.Recipients {
				z.Recipients[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Recipients", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelJoinCallData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Node) + 17 + msgp.BoolSize + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.Recipients {
		s += msgp.StringPrefixSize + len(z.Recipients[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelMessageBulkDeleteData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ids"
	o = append(o, 0x81, 0xa3, 0x69, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IDs)))
	for za0001 := range z.IDs {
		o = msgp.AppendString(o, z.IDs[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelMessageBulkDeleteData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ids":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IDs")
				return
			}
			if cap(z.IDs) >= int(zb0002) {
				z.IDs = (z.IDs)[:zb0002]
			} else {
				z.IDs = make([]string, zb0002)
			}
			for za0001 := range z.IDs {
				z.IDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IDs", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelMessageBulkDeleteData) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.IDs {
		s += msgp.StringPrefixSize + len(z.IDs[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelMessagesParams) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "limit"
	o = append(o, 0x86, 0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
	o = msgp.AppendInt(o, z.Limit)
	// string "before"
	o = append(o, 0xa6, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
	o = msgp.AppendString(o, z.Before)
	// string "after"
	o = append(o, 0xa5, 0x61, 0x66, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.After)
	// string "sort"
	o = append(o, 0xa4, 0x73, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, string(z.Sort))
	// string "nearby"
	o = append(o, 0xa6, 0x6e, 0x65, 0x61, 0x72, 0x62, 0x79)
	o = msgp.AppendString(o, z.Nearby)
	// string "include_users"
	o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendBool(o, z.IncludeUsers)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelMessagesParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "limit":
			z.Limit, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
		case "before":
			z.Before, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Before")
				return
			}
		case "after":
			z.After, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "After")
				return
			}
		case "sort":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sort")
					return
				}
				z.Sort = ChannelMessagesParamsSortType(zb0002)
			}
		case "nearby":
			z.Nearby, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nearby")
				return
			}
		case "include_users":
			z.IncludeUsers, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncludeUsers")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelMessagesParams) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 7 + msgp.StringPrefixSize + len(z.Before) + 6 + msgp.StringPrefixSize + len(z.After) + 5 + msgp.StringPrefixSize + len(string(z.Sort)) + 7 + msgp.StringPrefixSize + len(z.Nearby) + 14 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ChannelMessagesParamsSortType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelMessagesParamsSortType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ChannelMessagesParamsSortType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ChannelMessagesParamsSortType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelSearchParams) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ChannelMessagesParams"
	o = append(o, 0x83, 0xb5, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73)
	o, err = z.ChannelMessagesParams.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChannelMessagesParams")
		return
	}
	// string "pinned"
	o = append(o, 0xa6, 0x70, 0x69, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Pinned)
	// string "query"
	o = append(o, 0xa5, 0x71, 0x75, 0x65, 0x72, 0x79)
	o = msgp.AppendString(o, z.Query)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelSearchParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ChannelMessagesParams":
			bts, err = z.ChannelMessagesParams.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelMessagesParams")
				return
			}
		case "pinned":
			z.Pinned, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pinned")
				return
			}
		case "query":
			z.Query, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Query")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelSearchParams) Msgsize() (s int) {
	s = 1 + 22 + z.ChannelMessagesParams.Msgsize() + 7 + msgp.BoolSize + 6 + msgp.StringPrefixSize + len(z.Query)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ChannelType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ChannelType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ChannelType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelUnread) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "_id"
	o = append(o, 0x83, 0xa3, 0x5f, 0x69, 0x64)
	// map header, size 2
	// string "channel"
	o = append(o, 0x82, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.ID.Channel)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.User)
	// string "last_id"
	o = append(o, 0xa7, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x64)
	if z.LastMessageID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.LastMessageID)
	}
	// string "mentions"
	o = append(o, 0xa8, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MentionIDs)))
	for za0001 := range z.MentionIDs {
		o = msgp.AppendString(o, z.MentionIDs[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelUnread) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				switch msgp.UnsafeString(field) {
				case "channel":
					z.ID.Channel, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "Channel")
						return
					}
				case "user":
					z.ID.User, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "User")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID")
						return
					}
				}
			}
		case "last_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastMessageID = nil
			} else {
				if z.LastMessageID == nil {
					z.LastMessageID = new(string)
				}
				*z.LastMessageID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMessageID")
					return
				}
			}
		case "mentions":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MentionIDs")
				return
			}
			if cap(z.MentionIDs) >= int(zb0003) {
				z.MentionIDs = (z.MentionIDs)[:zb0003]
			} else {
				z.MentionIDs = make([]string, zb0003)
			}
			for za0001 := range z.MentionIDs {
				z.MentionIDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MentionIDs", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelUnread) Msgsize() (s int) {
	s = 1 + 4 + 1 + 8 + msgp.StringPrefixSize + len(z.ID.Channel) + 5 + msgp.StringPrefixSize + len(z.ID.User) + 8
	if z.LastMessageID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LastMessageID)
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0001 := range z.MentionIDs {
		s += msgp.StringPrefixSize + len(z.MentionIDs[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ChannelUnreadCompositeID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "channel"
	o = append(o, 0x82, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelUnreadCompositeID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ChannelUnreadCompositeID) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Channel) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelVoiceInformation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "max_users"
	o = append(o, 0x81, 0xa9, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73)
	if z.MaxUsers == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MaxUsers)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelVoiceInformation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "max_users":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MaxUsers = nil
			} else {
				if z.MaxUsers == nil {
					z.MaxUsers = new(int)
				}
				*z.MaxUsers, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MaxUsers")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelVoiceInformation) Msgsize() (s int) {
	s = 1 + 10
	if z.MaxUsers == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChannelVoiceState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "participants"
	o = append(o, 0xac, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x69, 0x70, 0x61, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Participants)))
	for za0001 := range z.Participants {
		if z.Participants[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Participants[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Participants", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChannelVoiceState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "participants":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Participants")
				return
			}
			if cap(z.Participants) >= int(zb0002) {
				z.Participants = (z.Participants)[:zb0002]
			} else {
				z.Participants = make([]*UserVoiceState, zb0002)
			}
			for za0001 := range z.Participants {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Participants[za0001] = nil
				} else {
					if z.Participants[za0001] == nil {
						z.Participants[za0001] = new(UserVoiceState)
					}
					bts, err = z.Participants[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Participants", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChannelVoiceState) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 13 + msgp.ArrayHeaderSize
	for za0001 := range z.Participants {
		if z.Participants[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Participants[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CompositeChannelID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "channel"
	o = append(o, 0x82, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CompositeChannelID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CompositeChannelID) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Channel) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Emoji) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "_id"
	o = append(o, 0x86, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "parent"
	o = append(o, 0xa6, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74)
	if z.Parent == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Parent.Type)
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.Parent.ID)
	}
	// string "creator_id"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.CreatorID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "animated"
	o = append(o, 0xa8, 0x61, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Animated)
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Emoji) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "parent":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Parent = nil
			} else {
				if z.Parent == nil {
					z.Parent = new(EmojiParent)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Parent")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Parent")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						z.Parent.Type, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "Type")
							return
						}
					case "id":
						z.Parent.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent")
							return
						}
					}
				}
			}
		case "creator_id":
			z.CreatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatorID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "animated":
			z.Animated, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Animated")
				return
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Emoji) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 7
	if z.Parent == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Parent.Type) + 3 + msgp.StringPrefixSize + len(z.Parent.ID)
	}
	s += 11 + msgp.StringPrefixSize + len(z.CreatorID) + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.BoolSize + 5 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EmojiCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "name"
	o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "parent"
	o = append(o, 0xa6, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74)
	if z.Parent == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Parent.Type)
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.Parent.ID)
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EmojiCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "parent":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Parent = nil
			} else {
				if z.Parent == nil {
					z.Parent = new(EmojiParent)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Parent")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Parent")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						z.Parent.Type, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "Type")
							return
						}
					case "id":
						z.Parent.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent")
							return
						}
					}
				}
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EmojiCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7
	if z.Parent == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Parent.Type) + 3 + msgp.StringPrefixSize + len(z.Parent.ID)
	}
	s += 5 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EmojiParent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EmojiParent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EmojiParent) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Event) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Event) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Event) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventAuth) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Event"
	o = append(o, 0x85, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "event_type"
	o = append(o, 0xaa, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.EventType))
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "session_id"
	o = append(o, 0xaa, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.SessionID)
	// string "exclude_session_id"
	o = append(o, 0xb2, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ExcludeSessionID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventAuth) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "event_type":
			{
				var zb0003 string
				zb0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EventType")
					return
				}
				z.EventType = AuthType(zb0003)
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "session_id":
			z.SessionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SessionID")
				return
			}
		case "exclude_session_id":
			z.ExcludeSessionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludeSessionID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventAuth) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 11 + msgp.StringPrefixSize + len(string(z.EventType)) + 8 + msgp.StringPrefixSize + len(z.UserID) + 11 + msgp.StringPrefixSize + len(z.SessionID) + 19 + msgp.StringPrefixSize + len(z.ExcludeSessionID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventAuthenticated) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventAuthenticated) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventAuthenticated) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventBulk) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Event"
	o = append(o, 0x82, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "v"
	o = append(o, 0xa1, 0x76)
	o = msgp.AppendArrayHeader(o, uint32(len(z.V)))
	for za0001 := range z.V {
		o, err = z.V[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "V", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventBulk) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "v":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "V")
				return
			}
			if cap(z.V) >= int(zb0003) {
				z.V = (z.V)[:zb0003]
			} else {
				z.V = make([]msgp.Raw, zb0003)
			}
			for za0001 := range z.V {
				bts, err = z.V[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "V", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventBulk) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.V {
		s += z.V[za0001].Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventBulkMessageDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "ids"
	o = append(o, 0xa3, 0x69, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IDs)))
	for za0001 := range z.IDs {
		o = msgp.AppendString(o, z.IDs[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventBulkMessageDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "ids":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IDs")
				return
			}
			if cap(z.IDs) >= int(zb0002) {
				z.IDs = (z.IDs)[:zb0002]
			} else {
				z.IDs = make([]string, zb0002)
			}
			for za0001 := range z.IDs {
				z.IDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IDs", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventBulkMessageDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 8 + msgp.StringPrefixSize + len(z.Channel) + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.IDs {
		s += msgp.StringPrefixSize + len(z.IDs[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventChannelAck) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "message_id"
	o = append(o, 0xaa, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.MessageID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelAck) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "message_id":
			z.MessageID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MessageID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventChannelAck) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User) + 11 + msgp.StringPrefixSize + len(z.MessageID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventChannelCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "type"
	o = append(o, 0xde, 0x0, 0x10, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_type"
	o = append(o, 0xac, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.ChannelType))
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if z.Description == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Description)
	}
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if z.Icon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Icon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Icon")
			return
		}
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	// string "active"
	o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
	o = msgp.AppendBool(o, z.Active)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	if z.Server == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Server)
	}
	// string "voice"
	o = append(o, 0xa5, 0x76, 0x6f, 0x69, 0x63, 0x65)
	if z.Voice == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "max_users"
		o = append(o, 0x81, 0xa9, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73)
		if z.Voice.MaxUsers == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Voice.MaxUsers)
		}
	}
	// string "role_permissions"
	o = append(o, 0xb0, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.RolePermissions)))
	for za0001, za0002 := range z.RolePermissions {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, za0002.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, za0002.Deny)
	}
	// string "recipients"
	o = append(o, 0xaa, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Recipients)))
	for za0003 := range z.Recipients {
		o = msgp.AppendString(o, z.Recipients[za0003])
	}
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.Permissions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Permissions)
	}
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "last_message_id"
	o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64)
	if z.LastMessageID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.LastMessageID)
	}
	// string "default_permissions"
	o = append(o, 0xb3, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.DefaultPermissions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Deny)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChannelType")
					return
				}
				z.ChannelType = ChannelType(zb0002)
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Description = nil
			} else {
				if z.Description == nil {
					z.Description = new(string)
				}
				*z.Description, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Description")
					return
				}
			}
		case "icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Icon = nil
			} else {
				if z.Icon == nil {
					z.Icon = new(Attachment)
				}
				bts, err = z.Icon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Icon")
					return
				}
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		case "active":
			z.Active, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		case "server":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Server = nil
			} else {
				if z.Server == nil {
					z.Server = new(string)
				}
				*z.Server, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Server")
					return
				}
			}
		case "voice":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Voice = nil
			} else {
				if z.Voice == nil {
					z.Voice = new(ChannelVoiceInformation)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Voice")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Voice")
						return
					}
					switch msgp.UnsafeString(field) {
					case "max_users":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Voice.MaxUsers = nil
						} else {
							if z.Voice.MaxUsers == nil {
								z.Voice.MaxUsers = new(int)
							}
							*z.Voice.MaxUsers, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Voice", "MaxUsers")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Voice")
							return
						}
					}
				}
			}
		case "role_permissions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RolePermissions")
				return
			}
			if z.RolePermissions == nil {
				z.RolePermissions = make(map[string]PermissionOverwrite, zb0004)
			} else if len(z.RolePermissions) > 0 {
				clear(z.RolePermissions)
			}
			for zb0004 > 0 {
				var za0002 PermissionOverwrite
				zb0004--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions", za0001)
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "RolePermissions", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						za0002.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Allow")
							return
						}
					case "d":
						za0002.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001)
							return
						}
					}
				}
				z.RolePermissions[za0001] = za0002
			}
		case "recipients":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recipients")
				return
			}
			if cap(z.Recipients) >= int(zb0006) {
				z.Recipients = (z.Recipients)[:zb0006]
			} else {
				z.Recipients = make([]string, zb0006)
			}
			for za0003 := range z.Recipients {
				z.Recipients[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Recipients", za0003)
					return
				}
			}
		case "permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Permissions = nil
			} else {
				if z.Permissions == nil {
					z.Permissions = new(int64)
				}
				*z.Permissions, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "last_message_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastMessageID = nil
			} else {
				if z.LastMessageID == nil {
					z.LastMessageID = new(string)
				}
				*z.LastMessageID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMessageID")
					return
				}
			}
		case "default_permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DefaultPermissions = nil
			} else {
				if z.DefaultPermissions == nil {
					z.DefaultPermissions = new(PermissionOverwrite)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DefaultPermissions")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "DefaultPermissions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						z.DefaultPermissions.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Allow")
							return
						}
					case "d":
						z.DefaultPermissions.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventChannelCreate) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.StringPrefixSize + len(z.ID) + 13 + msgp.StringPrefixSize + len(string(z.ChannelType)) + 5 + msgp.StringPrefixSize + len(z.Name) + 12
	if z.Description == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Description)
	}
	s += 5
	if z.Icon == nil {
		s += msgp.NilSize
	} else {
		s += z.Icon.Msgsize()
	}
	s += 5 + msgp.BoolSize + 7 + msgp.BoolSize + 7
	if z.Server == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Server)
	}
	s += 6
	if z.Voice == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10
		if z.Voice.MaxUsers == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	s += 17 + msgp.MapHeaderSize
	if z.RolePermissions != nil {
		for za0001, za0002 := range z.RolePermissions {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for za0003 := range z.Recipients {
		s += msgp.StringPrefixSize + len(z.Recipients[za0003])
	}
	s += 12
	if z.Permissions == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 6 + msgp.StringPrefixSize + len(z.Owner) + 16
	if z.LastMessageID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LastMessageID)
	}
	s += 20
	if z.DefaultPermissions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventChannelDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventChannelDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventChannelGroupJoin) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelGroupJoin) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventChannelGroupJoin) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventChannelGroupLeave) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelGroupLeave) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventChannelGroupLeave) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventChannelStartTyping) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelStartTyping) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventChannelStartTyping) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventChannelStopTyping) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelStopTyping) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventChannelStopTyping) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventChannelUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "clear"
	o = append(o, 0xa5, 0x63, 0x6c, 0x65, 0x61, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clear)))
	for za0001 := range z.Clear {
		o = msgp.AppendString(o, z.Clear[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventChannelUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "clear":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clear")
				return
			}
			if cap(z.Clear) >= int(zb0002) {
				z.Clear = (z.Clear)[:zb0002]
			} else {
				z.Clear = make([]string, zb0002)
			}
			for za0001 := range z.Clear {
				z.Clear[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clear", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventChannelUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + z.Data.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Clear {
		s += msgp.StringPrefixSize + len(z.Clear[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventEmojiCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "type"
	o = append(o, 0x87, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "parent"
	o = append(o, 0xa6, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74)
	if z.Parent == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.Parent.Type)
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.Parent.ID)
	}
	// string "creator_id"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.CreatorID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "animated"
	o = append(o, 0xa8, 0x61, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Animated)
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventEmojiCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "parent":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Parent = nil
			} else {
				if z.Parent == nil {
					z.Parent = new(EmojiParent)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Parent")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Parent")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						z.Parent.Type, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "Type")
							return
						}
					case "id":
						z.Parent.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Parent")
							return
						}
					}
				}
			}
		case "creator_id":
			z.CreatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatorID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "animated":
			z.Animated, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Animated")
				return
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventEmojiCreate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.StringPrefixSize + len(z.ID) + 7
	if z.Parent == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Parent.Type) + 3 + msgp.StringPrefixSize + len(z.Parent.ID)
	}
	s += 11 + msgp.StringPrefixSize + len(z.CreatorID) + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.BoolSize + 5 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventEmojiDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventEmojiDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventEmojiDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventError) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Event"
	o = append(o, 0x82, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "error"
	o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
	o = msgp.AppendString(o, string(z.Error))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventError) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "error":
			{
				var zb0003 string
				zb0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				z.Error = EventErrorType(zb0003)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventError) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 6 + msgp.StringPrefixSize + len(string(z.Error))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventErrorType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventErrorType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = EventErrorType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventErrorType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "type"
	o = append(o, 0xde, 0x0, 0x12, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "nonce"
	o = append(o, 0xa5, 0x6e, 0x6f, 0x6e, 0x63, 0x65)
	o = msgp.AppendString(o, z.Nonce)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "author"
	o = append(o, 0xa6, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Author)
	// string "content"
	o = append(o, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "mentions"
	o = append(o, 0xa8, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Mentions)))
	for za0001 := range z.Mentions {
		o = msgp.AppendString(o, z.Mentions[za0001])
	}
	// string "replies"
	o = append(o, 0xa7, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Replies)))
	for za0002 := range z.Replies {
		o = msgp.AppendString(o, z.Replies[za0002])
	}
	// string "reactions"
	o = append(o, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Reactions)))
	for za0003, za0004 := range z.Reactions {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendArrayHeader(o, uint32(len(za0004)))
		for za0005 := range za0004 {
			o = msgp.AppendString(o, za0004[za0005])
		}
	}
	// string "pinned"
	o = append(o, 0xa6, 0x70, 0x69, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Pinned)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, uint32(z.Flags))
	// string "webhook"
	o = append(o, 0xa7, 0x77, 0x65, 0x62, 0x68, 0x6f, 0x6f, 0x6b)
	if z.Webhook == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "name"
		o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Webhook.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		if z.Webhook.Avatar == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Webhook.Avatar)
		}
	}
	// string "system"
	o = append(o, 0xa6, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	if z.System == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, string(z.System.Type))
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.System.ID)
	}
	// string "embeds"
	o = append(o, 0xa6, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Embeds)))
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Embeds[za0006].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Embeds", za0006)
				return
			}
		}
	}
	// string "attachments"
	o = append(o, 0xab, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Attachments)))
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Attachments[za0007].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Attachments", za0007)
				return
			}
		}
	}
	// string "edited"
	o = append(o, 0xa6, 0x65, 0x64, 0x69, 0x74, 0x65, 0x64)
	if z.Edited == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendTime(o, *z.Edited)
	}
	// string "interactions"
	o = append(o, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if z.Interactions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "reactions"
		o = append(o, 0x82, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Interactions.Reactions)))
		for za0008 := range z.Interactions.Reactions {
			o = msgp.AppendString(o, z.Interactions.Reactions[za0008])
		}
		// string "restrict_reactions"
		o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendBool(o, z.Interactions.RestrictReactions)
	}
	// string "masquerade"
	o = append(o, 0xaa, 0x6d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65)
	if z.Masquerade == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "name"
		o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Masquerade.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Avatar)
		// string "colour"
		o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Colour)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "nonce":
			z.Nonce, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nonce")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "author":
			z.Author, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Author")
				return
			}
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "mentions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mentions")
				return
			}
			if cap(z.Mentions) >= int(zb0002) {
				z.Mentions = (z.Mentions)[:zb0002]
			} else {
				z.Mentions = make([]string, zb0002)
			}
			for za0001 := range z.Mentions {
				z.Mentions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mentions", za0001)
					return
				}
			}
		case "replies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Replies")
				return
			}
			if cap(z.Replies) >= int(zb0003) {
				z.Replies = (z.Replies)[:zb0003]
			} else {
				z.Replies = make([]string, zb0003)
			}
			for za0002 := range z.Replies {
				z.Replies[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replies", za0002)
					return
				}
			}
		case "reactions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reactions")
				return
			}
			if z.Reactions == nil {
				z.Reactions = make(map[string][]string, zb0004)
			} else if len(z.Reactions) > 0 {
				clear(z.Reactions)
			}
			for zb0004 > 0 {
				var za0004 []string
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions", za0003)
					return
				}
				if cap(za0004) >= int(zb0005) {
					za0004 = (za0004)[:zb0005]
				} else {
					za0004 = make([]string, zb0005)
				}
				for za0005 := range za0004 {
					za0004[za0005], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reactions", za0003, za0005)
						return
					}
				}
				z.Reactions[za0003] = za0004
			}
		case "pinned":
			z.Pinned, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pinned")
				return
			}
		case "flags":
			{
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
				z.Flags = MessageFlagsType(zb0006)
			}
		case "webhook":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Webhook = nil
			} else {
				if z.Webhook == nil {
					z.Webhook = new(MessageWebhook)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Webhook")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Webhook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Webhook.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook", "Name")
							return
						}
					case "avatar":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Webhook.Avatar = nil
						} else {
							if z.Webhook.Avatar == nil {
								z.Webhook.Avatar = new(string)
							}
							*z.Webhook.Avatar, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Webhook", "Avatar")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook")
							return
						}
					}
				}
			}
		case "system":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.System = nil
			} else {
				if z.System == nil {
					z.System = new(MessageSystem)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "System")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "System")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						{
							var zb0009 string
							zb0009, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "System", "Type")
								return
							}
							z.System.Type = MessageSystemType(zb0009)
						}
					case "id":
						z.System.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "System", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "System")
							return
						}
					}
				}
			}
		case "embeds":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Embeds")
				return
			}
			if cap(z.Embeds) >= int(zb0010) {
				z.Embeds = (z.Embeds)[:zb0010]
			} else {
				z.Embeds = make([]*MessageEmbed, zb0010)
			}
			for za0006 := range z.Embeds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Embeds[za0006] = nil
				} else {
					if z.Embeds[za0006] == nil {
						z.Embeds[za0006] = new(MessageEmbed)
					}
					bts, err = z.Embeds[za0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Embeds", za0006)
						return
					}
				}
			}
		case "attachments":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Attachments")
				return
			}
			if cap(z.Attachments) >= int(zb0011) {
				z.Attachments = (z.Attachments)[:zb0011]
			} else {
				z.Attachments = make([]*Attachment, zb0011)
			}
			for za0007 := range z.Attachments {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Attachments[za0007] = nil
				} else {
					if z.Attachments[za0007] == nil {
						z.Attachments[za0007] = new(Attachment)
					}
					bts, err = z.Attachments[za0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Attachments", za0007)
						return
					}
				}
			}
		case "edited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Edited = nil
			} else {
				if z.Edited == nil {
					z.Edited = new(time.Time)
				}
				*z.Edited, bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Edited")
					return
				}
			}
		case "interactions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Interactions = nil
			} else {
				if z.Interactions == nil {
					z.Interactions = new(MessageInteractions)
				}
				var zb0012 uint32
				zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interactions")
					return
				}
				for zb0012 > 0 {
					zb0012--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Interactions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "reactions":
						var zb0013 uint32
						zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "Reactions")
							return
						}
						if cap(z.Interactions.Reactions) >= int(zb0013) {
							z.Interactions.Reactions = (z.Interactions.Reactions)[:zb0013]
						} else {
							z.Interactions.Reactions = make([]string, zb0013)
						}
						for za0008 := range z.Interactions.Reactions {
							z.Interactions.Reactions[za0008], bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Interactions", "Reactions", za0008)
								return
							}
						}
					case "restrict_reactions":
						z.Interactions.RestrictReactions, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "RestrictReactions")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions")
							return
						}
					}
				}
			}
		case "masquerade":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Masquerade = nil
			} else {
				if z.Masquerade == nil {
					z.Masquerade = new(MessageMasquerade)
				}
				var zb0014 uint32
				zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Masquerade")
					return
				}
				for zb0014 > 0 {
					zb0014--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Masquerade")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Masquerade.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Name")
							return
						}
					case "avatar":
						z.Masquerade.Avatar, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Avatar")
							return
						}
					case "colour":
						z.Masquerade.Colour, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Colour")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventMessage) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Nonce) + 8 + msgp.StringPrefixSize + len(z.Channel) + 7 + msgp.StringPrefixSize + len(z.Author) + 8 + msgp.StringPrefixSize + len(z.Content) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Mentions {
		s += msgp.StringPrefixSize + len(z.Mentions[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Replies {
		s += msgp.StringPrefixSize + len(z.Replies[za0002])
	}
	s += 10 + msgp.MapHeaderSize
	if z.Reactions != nil {
		for za0003, za0004 := range z.Reactions {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.ArrayHeaderSize
			for za0005 := range za0004 {
				s += msgp.StringPrefixSize + len(za0004[za0005])
			}
		}
	}
	s += 7 + msgp.BoolSize + 6 + msgp.Uint32Size + 8
	if z.Webhook == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Webhook.Name) + 7
		if z.Webhook.Avatar == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(*z.Webhook.Avatar)
		}
	}
	s += 7
	if z.System == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(string(z.System.Type)) + 3 + msgp.StringPrefixSize + len(z.System.ID)
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += z.Embeds[za0006].Msgsize()
		}
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			s += msgp.NilSize
		} else {
			s += z.Attachments[za0007].Msgsize()
		}
	}
	s += 7
	if z.Edited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13
	if z.Interactions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.ArrayHeaderSize
		for za0008 := range z.Interactions.Reactions {
			s += msgp.StringPrefixSize + len(z.Interactions.Reactions[za0008])
		}
		s += 19 + msgp.BoolSize
	}
	s += 11
	if z.Masquerade == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Masquerade.Name) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Avatar) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Colour)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventMessageAppend) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "append"
	o = append(o, 0xa6, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64)
	o, err = z.Append.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Append")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageAppend) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "append":
			bts, err = z.Append.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Append")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventMessageAppend) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.Channel) + 7 + z.Append.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventMessageDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventMessageDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.Channel)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventMessageReact) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "emoji_id"
	o = append(o, 0xa8, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.EmojiID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageReact) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "emoji_id":
			z.EmojiID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EmojiID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventMessageReact) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 8 + msgp.StringPrefixSize + len(z.UserID) + 9 + msgp.StringPrefixSize + len(z.EmojiID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventMessageRemoveReaction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "emoji_id"
	o = append(o, 0xa8, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.EmojiID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageRemoveReaction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "emoji_id":
			z.EmojiID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EmojiID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventMessageRemoveReaction) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 9 + msgp.StringPrefixSize + len(z.EmojiID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventMessageUnreact) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "emoji_id"
	o = append(o, 0xa8, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.EmojiID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageUnreact) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "emoji_id":
			z.EmojiID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EmojiID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventMessageUnreact) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 8 + msgp.StringPrefixSize + len(z.UserID) + 9 + msgp.StringPrefixSize + len(z.EmojiID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventMessageUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventMessageUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventMessageUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.Channel) + 5 + z.Data.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventPong) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Event"
	o = append(o, 0x82, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o = msgp.AppendInt64(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventPong) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "data":
			z.Data, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventPong) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 5 + msgp.Int64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventReady) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "Event"
	o = append(o, 0x89, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0001 := range z.Users {
		if z.Users[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0001)
				return
			}
		}
	}
	// string "servers"
	o = append(o, 0xa7, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Servers)))
	for za0002 := range z.Servers {
		if z.Servers[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Servers[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Servers", za0002)
				return
			}
		}
	}
	// string "channels"
	o = append(o, 0xa8, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Channels)))
	for za0003 := range z.Channels {
		if z.Channels[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Channels[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Channels", za0003)
				return
			}
		}
	}
	// string "members"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0004 := range z.Members {
		if z.Members[za0004] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Members[za0004].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Members", za0004)
				return
			}
		}
	}
	// string "emojis"
	o = append(o, 0xa6, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Emojis)))
	for za0005 := range z.Emojis {
		if z.Emojis[za0005] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Emojis[za0005].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Emojis", za0005)
				return
			}
		}
	}
	// string "voice_states"
	o = append(o, 0xac, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.VoiceStates)))
	for za0006 := range z.VoiceStates {
		if z.VoiceStates[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "id"
			o = append(o, 0x82, 0xa2, 0x69, 0x64)
			o = msgp.AppendString(o, z.VoiceStates[za0006].ID)
			// string "participants"
			o = append(o, 0xac, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x69, 0x70, 0x61, 0x6e, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.VoiceStates[za0006].Participants)))
			for za0007 := range z.VoiceStates[za0006].Participants {
				if z.VoiceStates[za0006].Participants[za0007] == nil {
					o = msgp.AppendNil(o)
				} else {
					o, err = z.VoiceStates[za0006].Participants[za0007].MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "VoiceStates", za0006, "Participants", za0007)
						return
					}
				}
			}
		}
	}
	// string "user_settings"
	o = append(o, 0xad, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.UserSettings)))
	for za0008, za0009 := range z.UserSettings {
		o = msgp.AppendString(o, za0008)
		o, err = msgp.AppendIntf(o, za0009)
		if err != nil {
			err = msgp.WrapError(err, "UserSettings", za0008)
			return
		}
	}
	// string "channel_unreads"
	o = append(o, 0xaf, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x75, 0x6e, 0x72, 0x65, 0x61, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChannelUnreads)))
	for za0010 := range z.ChannelUnreads {
		o, err = z.ChannelUnreads[za0010].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ChannelUnreads", za0010)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventReady) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "users":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0003) {
				z.Users = (z.Users)[:zb0003]
			} else {
				z.Users = make([]*User, zb0003)
			}
			for za0001 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0001] = nil
				} else {
					if z.Users[za0001] == nil {
						z.Users[za0001] = new(User)
					}
					bts, err = z.Users[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0001)
						return
					}
				}
			}
		case "servers":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Servers")
				return
			}
			if cap(z.Servers) >= int(zb0004) {
				z.Servers = (z.Servers)[:zb0004]
			} else {
				z.Servers = make([]*Server, zb0004)
			}
			for za0002 := range z.Servers {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Servers[za0002] = nil
				} else {
					if z.Servers[za0002] == nil {
						z.Servers[za0002] = new(Server)
					}
					bts, err = z.Servers[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Servers", za0002)
						return
					}
				}
			}
		case "channels":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
			if cap(z.Channels) >= int(zb0005) {
				z.Channels = (z.Channels)[:zb0005]
			} else {
				z.Channels = make([]*Channel, zb0005)
			}
			for za0003 := range z.Channels {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Channels[za0003] = nil
				} else {
					if z.Channels[za0003] == nil {
						z.Channels[za0003] = new(Channel)
					}
					bts, err = z.Channels[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Channels", za0003)
						return
					}
				}
			}
		case "members":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0006) {
				z.Members = (z.Members)[:zb0006]
			} else {
				z.Members = make([]*ServerMember, zb0006)
			}
			for za0004 := range z.Members {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Members[za0004] = nil
				} else {
					if z.Members[za0004] == nil {
						z.Members[za0004] = new(ServerMember)
					}
					bts, err = z.Members[za0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Members", za0004)
						return
					}
				}
			}
		case "emojis":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Emojis")
				return
			}
			if cap(z.Emojis) >= int(zb0007) {
				z.Emojis = (z.Emojis)[:zb0007]
			} else {
				z.Emojis = make([]*Emoji, zb0007)
			}
			for za0005 := range z.Emojis {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Emojis[za0005] = nil
				} else {
					if z.Emojis[za0005] == nil {
						z.Emojis[za0005] = new(Emoji)
					}
					bts, err = z.Emojis[za0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Emojis", za0005)
						return
					}
				}
			}
		case "voice_states":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VoiceStates")
				return
			}
			if cap(z.VoiceStates) >= int(zb0008) {
				z.VoiceStates = (z.VoiceStates)[:zb0008]
			} else {
				z.VoiceStates = make([]*ChannelVoiceState, zb0008)
			}
			for za0006 := range z.VoiceStates {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.VoiceStates[za0006] = nil
				} else {
					if z.VoiceStates[za0006] == nil {
						z.VoiceStates[za0006] = new(ChannelVoiceState)
					}
					var zb0009 uint32
					zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoiceStates", za0006)
						return
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "VoiceStates", za0006)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.VoiceStates[za0006].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "VoiceStates", za0006, "ID")
								return
							}
						case "participants":
							var zb0010 uint32
							zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "VoiceStates", za0006, "Participants")
								return
							}
							if cap(z.VoiceStates[za0006].Participants) >= int(zb0010) {
								z.VoiceStates[za0006].Participants = (z.VoiceStates[za0006].Participants)[:zb0010]
							} else {
								z.VoiceStates[za0006].Participants = make([]*UserVoiceState, zb0010)
							}
							for za0007 := range z.VoiceStates[za0006].Participants {
								if msgp.IsNil(bts) {
									bts, err = msgp.ReadNilBytes(bts)
									if err != nil {
										return
									}
									z.VoiceStates[za0006].Participants[za0007] = nil
								} else {
									if z.VoiceStates[za0006].Participants[za0007] == nil {
										z.VoiceStates[za0006].Participants[za0007] = new(UserVoiceState)
									}
									bts, err = z.VoiceStates[za0006].Participants[za0007].UnmarshalMsg(bts)
									if err != nil {
										err = msgp.WrapError(err, "VoiceStates", za0006, "Participants", za0007)
										return
									}
								}
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "VoiceStates", za0006)
								return
							}
						}
					}
				}
			}
		case "user_settings":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserSettings")
				return
			}
			if z.UserSettings == nil {
				z.UserSettings = make(map[string]interface{}, zb0011)
			} else if len(z.UserSettings) > 0 {
				clear(z.UserSettings)
			}
			for zb0011 > 0 {
				var za0009 interface{}
				zb0011--
				var za0008 string
				za0008, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserSettings")
					return
				}
				za0009, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserSettings", za0008)
					return
				}
				z.UserSettings[za0008] = za0009
			}
		case "channel_unreads":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelUnreads")
				return
			}
			if cap(z.ChannelUnreads) >= int(zb0012) {
				z.ChannelUnreads = (z.ChannelUnreads)[:zb0012]
			} else {
				z.ChannelUnreads = make([]ChannelUnread, zb0012)
			}
			for za0010 := range z.ChannelUnreads {
				bts, err = z.ChannelUnreads[za0010].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChannelUnreads", za0010)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventReady) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Users {
		if z.Users[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0001].Msgsize()
		}
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Servers {
		if z.Servers[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Servers[za0002].Msgsize()
		}
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0003 := range z.Channels {
		if z.Channels[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += z.Channels[za0003].Msgsize()
		}
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0004 := range z.Members {
		if z.Members[za0004] == nil {
			s += msgp.NilSize
		} else {
			s += z.Members[za0004].Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0005 := range z.Emojis {
		if z.Emojis[za0005] == nil {
			s += msgp.NilSize
		} else {
			s += z.Emojis[za0005].Msgsize()
		}
	}
	s += 13 + msgp.ArrayHeaderSize
	for za0006 := range z.VoiceStates {
		if z.VoiceStates[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.StringPrefixSize + len(z.VoiceStates[za0006].ID) + 13 + msgp.ArrayHeaderSize
			for za0007 := range z.VoiceStates[za0006].Participants {
				if z.VoiceStates[za0006].Participants[za0007] == nil {
					s += msgp.NilSize
				} else {
					s += z.VoiceStates[za0006].Participants[za0007].Msgsize()
				}
			}
		}
	}
	s += 14 + msgp.MapHeaderSize
	if z.UserSettings != nil {
		for za0008, za0009 := range z.UserSettings {
			_ = za0009
			s += msgp.StringPrefixSize + len(za0008) + msgp.GuessSize(za0009)
		}
	}
	s += 16 + msgp.ArrayHeaderSize
	for za0010 := range z.ChannelUnreads {
		s += z.ChannelUnreads[za0010].Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventReportCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventReportCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventReportCreate) Msgsize() (s int) {
	s = 1
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	if z.Server == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Server.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Server")
			return
		}
	}
	// string "channels"
	o = append(o, 0xa8, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Channels)))
	for za0001 := range z.Channels {
		if z.Channels[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Channels[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Channels", za0001)
				return
			}
		}
	}
	// string "emojis"
	o = append(o, 0xa6, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Emojis)))
	for za0002 := range z.Emojis {
		if z.Emojis[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Emojis[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Emojis", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "server":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Server = nil
			} else {
				if z.Server == nil {
					z.Server = new(Server)
				}
				bts, err = z.Server.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Server")
					return
				}
			}
		case "channels":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
			if cap(z.Channels) >= int(zb0002) {
				z.Channels = (z.Channels)[:zb0002]
			} else {
				z.Channels = make([]*Channel, zb0002)
			}
			for za0001 := range z.Channels {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Channels[za0001] = nil
				} else {
					if z.Channels[za0001] == nil {
						z.Channels[za0001] = new(Channel)
					}
					bts, err = z.Channels[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Channels", za0001)
						return
					}
				}
			}
		case "emojis":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Emojis")
				return
			}
			if cap(z.Emojis) >= int(zb0003) {
				z.Emojis = (z.Emojis)[:zb0003]
			} else {
				z.Emojis = make([]*Emoji, zb0003)
			}
			for za0002 := range z.Emojis {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Emojis[za0002] = nil
				} else {
					if z.Emojis[za0002] == nil {
						z.Emojis[za0002] = new(Emoji)
					}
					bts, err = z.Emojis[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Emojis", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerCreate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 7
	if z.Server == nil {
		s += msgp.NilSize
	} else {
		s += z.Server.Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Channels {
		if z.Channels[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Channels[za0001].Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Emojis {
		if z.Emojis[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Emojis[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventServerDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventServerDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventServerMemberJoin) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerMemberJoin) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventServerMemberJoin) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerMemberLeave) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "reason"
	o = append(o, 0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Reason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerMemberLeave) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "reason":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerMemberLeave) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User) + 7 + msgp.StringPrefixSize + len(z.Reason)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerMemberUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	// map header, size 2
	// string "user"
	o = append(o, 0x82, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.User)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.Server)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "clear"
	o = append(o, 0xa5, 0x63, 0x6c, 0x65, 0x61, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clear)))
	for za0001 := range z.Clear {
		o = msgp.AppendString(o, z.Clear[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerMemberUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				switch msgp.UnsafeString(field) {
				case "user":
					z.ID.User, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "User")
						return
					}
				case "server":
					z.ID.Server, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "Server")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID")
						return
					}
				}
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "clear":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clear")
				return
			}
			if cap(z.Clear) >= int(zb0003) {
				z.Clear = (z.Clear)[:zb0003]
			} else {
				z.Clear = make([]string, zb0003)
			}
			for za0001 := range z.Clear {
				z.Clear[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clear", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerMemberUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + 1 + 5 + msgp.StringPrefixSize + len(z.ID.User) + 7 + msgp.StringPrefixSize + len(z.ID.Server) + 5 + z.Data.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Clear {
		s += msgp.StringPrefixSize + len(z.Clear[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventServerRoleDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "role_id"
	o = append(o, 0xa7, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.RoleID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerRoleDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "role_id":
			z.RoleID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RoleID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventServerRoleDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.RoleID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerRoleRanksUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "ranks"
	o = append(o, 0xa5, 0x72, 0x61, 0x6e, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Ranks)))
	for za0001 := range z.Ranks {
		o = msgp.AppendString(o, z.Ranks[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerRoleRanksUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ranks":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ranks")
				return
			}
			if cap(z.Ranks) >= int(zb0002) {
				z.Ranks = (z.Ranks)[:zb0002]
			} else {
				z.Ranks = make([]string, zb0002)
			}
			for za0001 := range z.Ranks {
				z.Ranks[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ranks", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerRoleRanksUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Ranks {
		s += msgp.StringPrefixSize + len(z.Ranks[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerRoleUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "role_id"
	o = append(o, 0xa7, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.RoleID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "clear"
	o = append(o, 0xa5, 0x63, 0x6c, 0x65, 0x61, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clear)))
	for za0001 := range z.Clear {
		o = msgp.AppendString(o, z.Clear[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerRoleUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "role_id":
			z.RoleID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RoleID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "clear":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clear")
				return
			}
			if cap(z.Clear) >= int(zb0002) {
				z.Clear = (z.Clear)[:zb0002]
			} else {
				z.Clear = make([]string, zb0002)
			}
			for za0001 := range z.Clear {
				z.Clear[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clear", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerRoleUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.RoleID) + 5 + z.Data.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Clear {
		s += msgp.StringPrefixSize + len(z.Clear[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventServerUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "clear"
	o = append(o, 0xa5, 0x63, 0x6c, 0x65, 0x61, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clear)))
	for za0001 := range z.Clear {
		o = msgp.AppendString(o, z.Clear[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventServerUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "clear":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clear")
				return
			}
			if cap(z.Clear) >= int(zb0002) {
				z.Clear = (z.Clear)[:zb0002]
			} else {
				z.Clear = make([]string, zb0002)
			}
			for za0001 := range z.Clear {
				z.Clear[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clear", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventServerUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + z.Data.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Clear {
		s += msgp.StringPrefixSize + len(z.Clear[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserMoveVoiceChannel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "node"
	o = append(o, 0xa4, 0x6e, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Node)
	// string "from"
	o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.From)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserMoveVoiceChannel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "node":
			z.Node, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Node")
				return
			}
		case "from":
			z.From, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserMoveVoiceChannel) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 5 + msgp.StringPrefixSize + len(z.Node) + 5 + msgp.StringPrefixSize + len(z.From) + 6 + msgp.StringPrefixSize + len(z.Token)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserPlatformWipe) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Event"
	o = append(o, 0x83, 0xa5, 0x45, 0x76, 0x65, 0x6e, 0x74)
	// map header, size 1
	// string "type"
	o = append(o, 0x81, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Event.Type)
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendInt(o, z.Flags)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserPlatformWipe) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Event":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Event")
					return
				}
				switch msgp.UnsafeString(field) {
				case "type":
					z.Event.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Event")
						return
					}
				}
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "flags":
			z.Flags, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserPlatformWipe) Msgsize() (s int) {
	s = 1 + 6 + 1 + 5 + msgp.StringPrefixSize + len(z.Event.Type) + 8 + msgp.StringPrefixSize + len(z.UserID) + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserRelationship) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	if z.User == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.User.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "User")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserRelationship) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.User = nil
			} else {
				if z.User == nil {
					z.User = new(User)
				}
				bts, err = z.User.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "User")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserRelationship) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5
	if z.User == nil {
		s += msgp.NilSize
	} else {
		s += z.User.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserSettingsUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "update"
	o = append(o, 0xa6, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65)
	o = msgp.AppendMapHeader(o, uint32(len(z.Update)))
	for za0001, za0002 := range z.Update {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "0"
		o = append(o, 0x82, 0xa1, 0x30)
		o = msgp.AppendTime(o, za0002.Timestamp)
		// string "1"
		o = append(o, 0xa1, 0x31)
		o, err = za0002.Value.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Update", za0001, "Value")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserSettingsUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "update":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Update")
				return
			}
			if z.Update == nil {
				z.Update = make(map[string]SyncSettingsDataTuple, zb0002)
			} else if len(z.Update) > 0 {
				clear(z.Update)
			}
			for zb0002 > 0 {
				var za0002 SyncSettingsDataTuple
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Update")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Update", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Update", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "0":
						za0002.Timestamp, bts, err = msgp.ReadTimeBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Update", za0001, "Timestamp")
							return
						}
					case "1":
						bts, err = za0002.Value.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Update", za0001, "Value")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Update", za0001)
							return
						}
					}
				}
				z.Update[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserSettingsUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 7 + msgp.MapHeaderSize
	if z.Update != nil {
		for za0001, za0002 := range z.Update {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 2 + msgp.TimeSize + 2 + za0002.Value.Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "type"
	o = append(o, 0x86, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "clear"
	o = append(o, 0xa5, 0x63, 0x6c, 0x65, 0x61, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clear)))
	for za0001 := range z.Clear {
		o = msgp.AppendString(o, z.Clear[za0001])
	}
	// string "event_id"
	o = append(o, 0xa8, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if z.EventID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.EventID)
	}
	// string "idiot"
	o = append(o, 0xa5, 0x69, 0x64, 0x69, 0x6f, 0x74)
	o = msgp.AppendBool(o, z.Idiot)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "clear":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clear")
				return
			}
			if cap(z.Clear) >= int(zb0002) {
				z.Clear = (z.Clear)[:zb0002]
			} else {
				z.Clear = make([]string, zb0002)
			}
			for za0001 := range z.Clear {
				z.Clear[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clear", za0001)
					return
				}
			}
		case "event_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EventID = nil
			} else {
				if z.EventID == nil {
					z.EventID = new(string)
				}
				*z.EventID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EventID")
					return
				}
			}
		case "idiot":
			z.Idiot, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Idiot")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + z.Data.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Clear {
		s += msgp.StringPrefixSize + len(z.Clear[za0001])
	}
	s += 9
	if z.EventID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.EventID)
	}
	s += 6 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventUserVoiceStateUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventUserVoiceStateUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventUserVoiceStateUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 5 + z.Data.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventVoiceChannelJoin) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "state"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	o, err = z.State.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventVoiceChannelJoin) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "state":
			bts, err = z.State.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventVoiceChannelJoin) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 6 + z.State.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventVoiceChannelLeave) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventVoiceChannelLeave) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventVoiceChannelLeave) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.User)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventVoiceChannelMove) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "from"
	o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.From)
	// string "to"
	o = append(o, 0xa2, 0x74, 0x6f)
	o = msgp.AppendString(o, z.To)
	// string "state"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	o, err = z.State.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventVoiceChannelMove) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "from":
			z.From, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		case "to":
			z.To, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "To")
				return
			}
		case "state":
			bts, err = z.State.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventVoiceChannelMove) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 5 + msgp.StringPrefixSize + len(z.User) + 5 + msgp.StringPrefixSize + len(z.From) + 3 + msgp.StringPrefixSize + len(z.To) + 6 + z.State.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventWebhookCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "type"
	o = append(o, 0x88, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "creator_id"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.CreatorID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendUint64(o, z.Permissions)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if z.Token == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Token)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventWebhookCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "creator_id":
			z.CreatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatorID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "permissions":
			z.Permissions, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		case "token":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Token = nil
			} else {
				if z.Token == nil {
					z.Token = new(string)
				}
				*z.Token, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Token")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventWebhookCreate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name) + 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 11 + msgp.StringPrefixSize + len(z.CreatorID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 12 + msgp.Uint64Size + 6
	if z.Token == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Token)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EventWebhookDelete) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventWebhookDelete) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EventWebhookDelete) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *EventWebhookUpdate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EventWebhookUpdate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "remove":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0002) {
				z.Remove = (z.Remove)[:zb0002]
			} else {
				z.Remove = make([]string, zb0002)
			}
			for za0001 := range z.Remove {
				z.Remove[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *EventWebhookUpdate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + z.Data.Msgsize() + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FetchedBot) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "bot"
	o = append(o, 0x82, 0xa3, 0x62, 0x6f, 0x74)
	if z.Bot == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Bot.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bot")
			return
		}
	}
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	if z.User == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.User.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "User")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FetchedBot) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Bot = nil
			} else {
				if z.Bot == nil {
					z.Bot = new(Bot)
				}
				bts, err = z.Bot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bot")
					return
				}
			}
		case "user":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.User = nil
			} else {
				if z.User == nil {
					z.User = new(User)
				}
				bts, err = z.User.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "User")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FetchedBot) Msgsize() (s int) {
	s = 1 + 4
	if z.Bot == nil {
		s += msgp.NilSize
	} else {
		s += z.Bot.Msgsize()
	}
	s += 5
	if z.User == nil {
		s += msgp.NilSize
	} else {
		s += z.User.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FetchedBots) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "bots"
	o = append(o, 0x82, 0xa4, 0x62, 0x6f, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bots)))
	for za0001 := range z.Bots {
		if z.Bots[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bots[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Bots", za0001)
				return
			}
		}
	}
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FetchedBots) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bots":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bots")
				return
			}
			if cap(z.Bots) >= int(zb0002) {
				z.Bots = (z.Bots)[:zb0002]
			} else {
				z.Bots = make([]*Bot, zb0002)
			}
			for za0001 := range z.Bots {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Bots[za0001] = nil
				} else {
					if z.Bots[za0001] == nil {
						z.Bots[za0001] = new(Bot)
					}
					bts, err = z.Bots[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Bots", za0001)
						return
					}
				}
			}
		case "users":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0003) {
				z.Users = (z.Users)[:zb0003]
			} else {
				z.Users = make([]*User, zb0003)
			}
			for za0002 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0002] = nil
				} else {
					if z.Users[za0002] == nil {
						z.Users[za0002] = new(User)
					}
					bts, err = z.Users[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FetchedBots) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize
	for za0001 := range z.Bots {
		if z.Bots[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Bots[za0001].Msgsize()
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FetchedGroupMembers) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "messages"
	o = append(o, 0x82, 0xa8, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Messages)))
	for za0001 := range z.Messages {
		if z.Messages[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Messages[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Messages", za0001)
				return
			}
		}
	}
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FetchedGroupMembers) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "messages":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Messages")
				return
			}
			if cap(z.Messages) >= int(zb0002) {
				z.Messages = (z.Messages)[:zb0002]
			} else {
				z.Messages = make([]*Message, zb0002)
			}
			for za0001 := range z.Messages {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Messages[za0001] = nil
				} else {
					if z.Messages[za0001] == nil {
						z.Messages[za0001] = new(Message)
					}
					bts, err = z.Messages[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Messages", za0001)
						return
					}
				}
			}
		case "users":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0003) {
				z.Users = (z.Users)[:zb0003]
			} else {
				z.Users = make([]*User, zb0003)
			}
			for za0002 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0002] = nil
				} else {
					if z.Users[za0002] == nil {
						z.Users[za0002] = new(User)
					}
					bts, err = z.Users[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FetchedGroupMembers) Msgsize() (s int) {
	s = 1 + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Messages {
		if z.Messages[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Messages[za0001].Msgsize()
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Group) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "_id"
	o = append(o, 0x85, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.OwnerID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0001 := range z.Users {
		o = msgp.AppendString(o, z.Users[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Group) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "owner":
			z.OwnerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OwnerID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "users":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0002) {
				z.Users = (z.Users)[:zb0002]
			} else {
				z.Users = make([]string, zb0002)
			}
			for za0001 := range z.Users {
				z.Users[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Users", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Group) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.OwnerID) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Users {
		s += msgp.StringPrefixSize + len(z.Users[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GroupCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "name"
	o = append(o, 0x84, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0001 := range z.Users {
		o = msgp.AppendString(o, z.Users[za0001])
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GroupCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "users":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0002) {
				z.Users = (z.Users)[:zb0002]
			} else {
				z.Users = make([]string, zb0002)
			}
			for za0001 := range z.Users {
				z.Users[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Users", za0001)
					return
				}
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GroupCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Users {
		s += msgp.StringPrefixSize + len(z.Users[za0001])
	}
	s += 5 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GroupSystemMessages) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "user_joined"
	o = append(o, 0x82, 0xab, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6a, 0x6f, 0x69, 0x6e, 0x65, 0x64)
	o = msgp.AppendString(o, z.UserJoined)
	// string "user_left"
	o = append(o, 0xa9, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6c, 0x65, 0x66, 0x74)
	o = msgp.AppendString(o, z.UserLeft)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GroupSystemMessages) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "user_joined":
			z.UserJoined, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserJoined")
				return
			}
		case "user_left":
			z.UserLeft, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserLeft")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GroupSystemMessages) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.UserJoined) + 10 + msgp.StringPrefixSize + len(z.UserLeft)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HTTPClient) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Debug"
	o = append(o, 0x81, 0xa5, 0x44, 0x65, 0x62, 0x75, 0x67)
	o = msgp.AppendBool(o, z.Debug)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HTTPClient) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Debug":
			z.Debug, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Debug")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HTTPClient) Msgsize() (s int) {
	s = 1 + 6 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Invite) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "type"
	o = append(o, 0x8c, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "server_id"
	o = append(o, 0xa9, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ServerID)
	// string "server_name"
	o = append(o, 0xab, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ServerName)
	// string "server_icon"
	o = append(o, 0xab, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x63, 0x6f, 0x6e)
	if z.ServerIcon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ServerIcon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ServerIcon")
			return
		}
	}
	// string "server_banner"
	o = append(o, 0xad, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	if z.ServerBanner == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ServerBanner.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ServerBanner")
			return
		}
	}
	// string "server_flags"
	o = append(o, 0xac, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.ServerFlags)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "channel_name"
	o = append(o, 0xac, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ChannelName)
	// string "channel_description"
	o = append(o, 0xb3, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.ChannelDescription)
	// string "user_name"
	o = append(o, 0xa9, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.UserName)
	// string "user_avatar"
	o = append(o, 0xab, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.UserAvatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.UserAvatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "UserAvatar")
			return
		}
	}
	// string "member_count"
	o = append(o, 0xac, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.MemberCount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Invite) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = InviteType(zb0002)
			}
		case "server_id":
			z.ServerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ServerID")
				return
			}
		case "server_name":
			z.ServerName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ServerName")
				return
			}
		case "server_icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ServerIcon = nil
			} else {
				if z.ServerIcon == nil {
					z.ServerIcon = new(Attachment)
				}
				bts, err = z.ServerIcon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ServerIcon")
					return
				}
			}
		case "server_banner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ServerBanner = nil
			} else {
				if z.ServerBanner == nil {
					z.ServerBanner = new(Attachment)
				}
				bts, err = z.ServerBanner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ServerBanner")
					return
				}
			}
		case "server_flags":
			z.ServerFlags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ServerFlags")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "channel_name":
			z.ChannelName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelName")
				return
			}
		case "channel_description":
			z.ChannelDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelDescription")
				return
			}
		case "user_name":
			z.UserName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserName")
				return
			}
		case "user_avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.UserAvatar = nil
			} else {
				if z.UserAvatar == nil {
					z.UserAvatar = new(Attachment)
				}
				bts, err = z.UserAvatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserAvatar")
					return
				}
			}
		case "member_count":
			z.MemberCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MemberCount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Invite) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 10 + msgp.StringPrefixSize + len(z.ServerID) + 12 + msgp.StringPrefixSize + len(z.ServerName) + 12
	if z.ServerIcon == nil {
		s += msgp.NilSize
	} else {
		s += z.ServerIcon.Msgsize()
	}
	s += 14
	if z.ServerBanner == nil {
		s += msgp.NilSize
	} else {
		s += z.ServerBanner.Msgsize()
	}
	s += 13 + msgp.Uint32Size + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 13 + msgp.StringPrefixSize + len(z.ChannelName) + 20 + msgp.StringPrefixSize + len(z.ChannelDescription) + 10 + msgp.StringPrefixSize + len(z.UserName) + 12
	if z.UserAvatar == nil {
		s += msgp.NilSize
	} else {
		s += z.UserAvatar.Msgsize()
	}
	s += 13 + msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InviteCreate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.Server)
	// string "creator"
	o = append(o, 0xa7, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Creator)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InviteCreate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = InviteType(zb0002)
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "server":
			z.Server, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Server")
				return
			}
		case "creator":
			z.Creator, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Creator")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InviteCreate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 4 + msgp.StringPrefixSize + len(z.ID) + 7 + msgp.StringPrefixSize + len(z.Server) + 8 + msgp.StringPrefixSize + len(z.Creator) + 8 + msgp.StringPrefixSize + len(z.Channel)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InviteJoin) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "type"
	o = append(o, 0x83, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "Channels"
	o = append(o, 0xa8, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Channels)))
	for za0001 := range z.Channels {
		if z.Channels[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Channels[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Channels", za0001)
				return
			}
		}
	}
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	if z.Server == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Server.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Server")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InviteJoin) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = InviteType(zb0002)
			}
		case "Channels":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
			if cap(z.Channels) >= int(zb0003) {
				z.Channels = (z.Channels)[:zb0003]
			} else {
				z.Channels = make([]*Channel, zb0003)
			}
			for za0001 := range z.Channels {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Channels[za0001] = nil
				} else {
					if z.Channels[za0001] == nil {
						z.Channels[za0001] = new(Channel)
					}
					bts, err = z.Channels[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Channels", za0001)
						return
					}
				}
			}
		case "server":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Server = nil
			} else {
				if z.Server == nil {
					z.Server = new(Server)
				}
				bts, err = z.Server.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Server")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InviteJoin) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Channels {
		if z.Channels[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Channels[za0001].Msgsize()
		}
	}
	s += 7
	if z.Server == nil {
		s += msgp.NilSize
	} else {
		s += z.Server.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z InviteType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InviteType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = InviteType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z InviteType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LoginData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "email"
	o = append(o, 0x83, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Email)
	// string "password"
	o = append(o, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	// string "friendly_name"
	o = append(o, 0xad, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x6c, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FriendlyName)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			z.Email, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Email")
				return
			}
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		case "friendly_name":
			z.FriendlyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FriendlyName")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LoginData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Email) + 9 + msgp.StringPrefixSize + len(z.Password) + 14 + msgp.StringPrefixSize + len(z.FriendlyName)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "result"
	o = append(o, 0x86, 0xa6, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74)
	o = msgp.AppendString(o, z.Result)
	// string "_id"
	o = append(o, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "user_id"
	o = append(o, 0xa7, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.UserID)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "subscription"
	o = append(o, 0xac, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	// map header, size 3
	// string "endpoint"
	o = append(o, 0x83, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Subscription.Endpoint)
	// string "p256dh"
	o = append(o, 0xa6, 0x70, 0x32, 0x35, 0x36, 0x64, 0x68)
	o = msgp.AppendString(o, z.Subscription.P256DH)
	// string "auth"
	o = append(o, 0xa4, 0x61, 0x75, 0x74, 0x68)
	o = msgp.AppendString(o, z.Subscription.Auth)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "result":
			z.Result, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "user_id":
			z.UserID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserID")
				return
			}
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "subscription":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Subscription")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subscription")
					return
				}
				switch msgp.UnsafeString(field) {
				case "endpoint":
					z.Subscription.Endpoint, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subscription", "Endpoint")
						return
					}
				case "p256dh":
					z.Subscription.P256DH, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subscription", "P256DH")
						return
					}
				case "auth":
					z.Subscription.Auth, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subscription", "Auth")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subscription")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginResponse) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Result) + 4 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.UserID) + 6 + msgp.StringPrefixSize + len(z.Token) + 5 + msgp.StringPrefixSize + len(z.Name) + 13 + 1 + 9 + msgp.StringPrefixSize + len(z.Subscription.Endpoint) + 7 + msgp.StringPrefixSize + len(z.Subscription.P256DH) + 5 + msgp.StringPrefixSize + len(z.Subscription.Auth)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFA) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "mfa_ticket"
	o = append(o, 0x83, 0xaa, 0x6d, 0x66, 0x61, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.MfaTicket)
	// string "mfa_response"
	o = append(o, 0xac, 0x6d, 0x66, 0x61, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65)
	// map header, size 1
	// string "password"
	o = append(o, 0x81, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.MfaResponse.Password)
	// string "friendly_name"
	o = append(o, 0xad, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x6c, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FriendlyName)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFA) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mfa_ticket":
			z.MfaTicket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MfaTicket")
				return
			}
		case "mfa_response":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MfaResponse")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "MfaResponse")
					return
				}
				switch msgp.UnsafeString(field) {
				case "password":
					z.MfaResponse.Password, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "MfaResponse", "Password")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "MfaResponse")
						return
					}
				}
			}
		case "friendly_name":
			z.FriendlyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FriendlyName")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFA) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.MfaTicket) + 13 + 1 + 9 + msgp.StringPrefixSize + len(z.MfaResponse.Password) + 14 + msgp.StringPrefixSize + len(z.FriendlyName)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MFAResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "password"
	o = append(o, 0x81, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MFAResponse) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Password)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFATicket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "_id"
	o = append(o, 0x86, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "account_id"
	o = append(o, 0xaa, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.AccountID)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	// string "validated"
	o = append(o, 0xa9, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Validated)
	// string "authorised"
	o = append(o, 0xaa, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x73, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Authorised)
	// string "last_totp_code"
	o = append(o, 0xae, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x74, 0x6f, 0x74, 0x70, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.LastTOTPCode)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFATicket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "account_id":
			z.AccountID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AccountID")
				return
			}
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "validated":
			z.Validated, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Validated")
				return
			}
		case "authorised":
			z.Authorised, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Authorised")
				return
			}
		case "last_totp_code":
			z.LastTOTPCode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastTOTPCode")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFATicket) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.StringPrefixSize + len(z.AccountID) + 6 + msgp.StringPrefixSize + len(z.Token) + 10 + msgp.BoolSize + 11 + msgp.BoolSize + 15 + msgp.StringPrefixSize + len(z.LastTOTPCode)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MemberCompositeID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "user"
	o = append(o, 0x82, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.Server)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemberCompositeID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "server":
			z.Server, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Server")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MemberCompositeID) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.User) + 7 + msgp.StringPrefixSize + len(z.Server)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Message) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "_id"
	o = append(o, 0xde, 0x0, 0x11, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "nonce"
	o = append(o, 0xa5, 0x6e, 0x6f, 0x6e, 0x63, 0x65)
	o = msgp.AppendString(o, z.Nonce)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "author"
	o = append(o, 0xa6, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Author)
	// string "content"
	o = append(o, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "mentions"
	o = append(o, 0xa8, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Mentions)))
	for za0001 := range z.Mentions {
		o = msgp.AppendString(o, z.Mentions[za0001])
	}
	// string "replies"
	o = append(o, 0xa7, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Replies)))
	for za0002 := range z.Replies {
		o = msgp.AppendString(o, z.Replies[za0002])
	}
	// string "reactions"
	o = append(o, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Reactions)))
	for za0003, za0004 := range z.Reactions {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendArrayHeader(o, uint32(len(za0004)))
		for za0005 := range za0004 {
			o = msgp.AppendString(o, za0004[za0005])
		}
	}
	// string "pinned"
	o = append(o, 0xa6, 0x70, 0x69, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Pinned)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, uint32(z.Flags))
	// string "webhook"
	o = append(o, 0xa7, 0x77, 0x65, 0x62, 0x68, 0x6f, 0x6f, 0x6b)
	if z.Webhook == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "name"
		o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Webhook.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		if z.Webhook.Avatar == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Webhook.Avatar)
		}
	}
	// string "system"
	o = append(o, 0xa6, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	if z.System == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, string(z.System.Type))
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.System.ID)
	}
	// string "embeds"
	o = append(o, 0xa6, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Embeds)))
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Embeds[za0006].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Embeds", za0006)
				return
			}
		}
	}
	// string "attachments"
	o = append(o, 0xab, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Attachments)))
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Attachments[za0007].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Attachments", za0007)
				return
			}
		}
	}
	// string "edited"
	o = append(o, 0xa6, 0x65, 0x64, 0x69, 0x74, 0x65, 0x64)
	if z.Edited == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendTime(o, *z.Edited)
	}
	// string "interactions"
	o = append(o, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if z.Interactions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "reactions"
		o = append(o, 0x82, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Interactions.Reactions)))
		for za0008 := range z.Interactions.Reactions {
			o = msgp.AppendString(o, z.Interactions.Reactions[za0008])
		}
		// string "restrict_reactions"
		o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendBool(o, z.Interactions.RestrictReactions)
	}
	// string "masquerade"
	o = append(o, 0xaa, 0x6d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65)
	if z.Masquerade == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "name"
		o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Masquerade.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Avatar)
		// string "colour"
		o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Colour)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Message) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "nonce":
			z.Nonce, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nonce")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "author":
			z.Author, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Author")
				return
			}
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "mentions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mentions")
				return
			}
			if cap(z.Mentions) >= int(zb0002) {
				z.Mentions = (z.Mentions)[:zb0002]
			} else {
				z.Mentions = make([]string, zb0002)
			}
			for za0001 := range z.Mentions {
				z.Mentions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mentions", za0001)
					return
				}
			}
		case "replies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Replies")
				return
			}
			if cap(z.Replies) >= int(zb0003) {
				z.Replies = (z.Replies)[:zb0003]
			} else {
				z.Replies = make([]string, zb0003)
			}
			for za0002 := range z.Replies {
				z.Replies[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replies", za0002)
					return
				}
			}
		case "reactions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reactions")
				return
			}
			if z.Reactions == nil {
				z.Reactions = make(map[string][]string, zb0004)
			} else if len(z.Reactions) > 0 {
				clear(z.Reactions)
			}
			for zb0004 > 0 {
				var za0004 []string
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions", za0003)
					return
				}
				if cap(za0004) >= int(zb0005) {
					za0004 = (za0004)[:zb0005]
				} else {
					za0004 = make([]string, zb0005)
				}
				for za0005 := range za0004 {
					za0004[za0005], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reactions", za0003, za0005)
						return
					}
				}
				z.Reactions[za0003] = za0004
			}
		case "pinned":
			z.Pinned, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pinned")
				return
			}
		case "flags":
			{
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
				z.Flags = MessageFlagsType(zb0006)
			}
		case "webhook":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Webhook = nil
			} else {
				if z.Webhook == nil {
					z.Webhook = new(MessageWebhook)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Webhook")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Webhook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Webhook.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook", "Name")
							return
						}
					case "avatar":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Webhook.Avatar = nil
						} else {
							if z.Webhook.Avatar == nil {
								z.Webhook.Avatar = new(string)
							}
							*z.Webhook.Avatar, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Webhook", "Avatar")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook")
							return
						}
					}
				}
			}
		case "system":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.System = nil
			} else {
				if z.System == nil {
					z.System = new(MessageSystem)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "System")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "System")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						{
							var zb0009 string
							zb0009, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "System", "Type")
								return
							}
							z.System.Type = MessageSystemType(zb0009)
						}
					case "id":
						z.System.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "System", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "System")
							return
						}
					}
				}
			}
		case "embeds":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Embeds")
				return
			}
			if cap(z.Embeds) >= int(zb0010) {
				z.Embeds = (z.Embeds)[:zb0010]
			} else {
				z.Embeds = make([]*MessageEmbed, zb0010)
			}
			for za0006 := range z.Embeds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Embeds[za0006] = nil
				} else {
					if z.Embeds[za0006] == nil {
						z.Embeds[za0006] = new(MessageEmbed)
					}
					bts, err = z.Embeds[za0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Embeds", za0006)
						return
					}
				}
			}
		case "attachments":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Attachments")
				return
			}
			if cap(z.Attachments) >= int(zb0011) {
				z.Attachments = (z.Attachments)[:zb0011]
			} else {
				z.Attachments = make([]*Attachment, zb0011)
			}
			for za0007 := range z.Attachments {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Attachments[za0007] = nil
				} else {
					if z.Attachments[za0007] == nil {
						z.Attachments[za0007] = new(Attachment)
					}
					bts, err = z.Attachments[za0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Attachments", za0007)
						return
					}
				}
			}
		case "edited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Edited = nil
			} else {
				if z.Edited == nil {
					z.Edited = new(time.Time)
				}
				*z.Edited, bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Edited")
					return
				}
			}
		case "interactions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Interactions = nil
			} else {
				if z.Interactions == nil {
					z.Interactions = new(MessageInteractions)
				}
				var zb0012 uint32
				zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interactions")
					return
				}
				for zb0012 > 0 {
					zb0012--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Interactions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "reactions":
						var zb0013 uint32
						zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "Reactions")
							return
						}
						if cap(z.Interactions.Reactions) >= int(zb0013) {
							z.Interactions.Reactions = (z.Interactions.Reactions)[:zb0013]
						} else {
							z.Interactions.Reactions = make([]string, zb0013)
						}
						for za0008 := range z.Interactions.Reactions {
							z.Interactions.Reactions[za0008], bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Interactions", "Reactions", za0008)
								return
							}
						}
					case "restrict_reactions":
						z.Interactions.RestrictReactions, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "RestrictReactions")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions")
							return
						}
					}
				}
			}
		case "masquerade":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Masquerade = nil
			} else {
				if z.Masquerade == nil {
					z.Masquerade = new(MessageMasquerade)
				}
				var zb0014 uint32
				zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Masquerade")
					return
				}
				for zb0014 > 0 {
					zb0014--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Masquerade")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Masquerade.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Name")
							return
						}
					case "avatar":
						z.Masquerade.Avatar, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Avatar")
							return
						}
					case "colour":
						z.Masquerade.Colour, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Colour")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Message) Msgsize() (s int) {
	s = 3 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Nonce) + 8 + msgp.StringPrefixSize + len(z.Channel) + 7 + msgp.StringPrefixSize + len(z.Author) + 8 + msgp.StringPrefixSize + len(z.Content) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Mentions {
		s += msgp.StringPrefixSize + len(z.Mentions[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Replies {
		s += msgp.StringPrefixSize + len(z.Replies[za0002])
	}
	s += 10 + msgp.MapHeaderSize
	if z.Reactions != nil {
		for za0003, za0004 := range z.Reactions {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.ArrayHeaderSize
			for za0005 := range za0004 {
				s += msgp.StringPrefixSize + len(za0004[za0005])
			}
		}
	}
	s += 7 + msgp.BoolSize + 6 + msgp.Uint32Size + 8
	if z.Webhook == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Webhook.Name) + 7
		if z.Webhook.Avatar == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(*z.Webhook.Avatar)
		}
	}
	s += 7
	if z.System == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(string(z.System.Type)) + 3 + msgp.StringPrefixSize + len(z.System.ID)
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += z.Embeds[za0006].Msgsize()
		}
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			s += msgp.NilSize
		} else {
			s += z.Attachments[za0007].Msgsize()
		}
	}
	s += 7
	if z.Edited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13
	if z.Interactions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.ArrayHeaderSize
		for za0008 := range z.Interactions.Reactions {
			s += msgp.StringPrefixSize + len(z.Interactions.Reactions[za0008])
		}
		s += 19 + msgp.BoolSize
	}
	s += 11
	if z.Masquerade == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Masquerade.Name) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Avatar) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Colour)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "content"
	o = append(o, 0x82, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "embeds"
	o = append(o, 0xa6, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Embeds)))
	for za0001 := range z.Embeds {
		if z.Embeds[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Embeds[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Embeds", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "embeds":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Embeds")
				return
			}
			if cap(z.Embeds) >= int(zb0002) {
				z.Embeds = (z.Embeds)[:zb0002]
			} else {
				z.Embeds = make([]*MessageEmbed, zb0002)
			}
			for za0001 := range z.Embeds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Embeds[za0001] = nil
				} else {
					if z.Embeds[za0001] == nil {
						z.Embeds[za0001] = new(MessageEmbed)
					}
					bts, err = z.Embeds[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Embeds", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageEditData) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Content) + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Embeds {
		if z.Embeds[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Embeds[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageEdited) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "$date"
	o = append(o, 0x81, 0xa5, 0x24, 0x64, 0x61, 0x74, 0x65)
	o = msgp.AppendInt(o, z.Date)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEdited) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "$date":
			z.Date, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageEdited) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageEmbed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "type"
	o = append(o, 0x8b, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "url"
	o = append(o, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	// string "original_url"
	o = append(o, 0xac, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.OriginalURL)
	// string "special"
	o = append(o, 0xa7, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c)
	if z.Special == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Special.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Special")
			return
		}
	}
	// string "title"
	o = append(o, 0xa5, 0x74, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "image"
	o = append(o, 0xa5, 0x69, 0x6d, 0x61, 0x67, 0x65)
	if z.Image == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Image.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Image")
			return
		}
	}
	// string "video"
	o = append(o, 0xa5, 0x76, 0x69, 0x64, 0x65, 0x6f)
	if z.Video == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "url"
		o = append(o, 0x83, 0xa3, 0x75, 0x72, 0x6c)
		o = msgp.AppendString(o, z.Video.URL)
		// string "width"
		o = append(o, 0xa5, 0x77, 0x69, 0x64, 0x74, 0x68)
		o = msgp.AppendInt(o, z.Video.Width)
		// string "height"
		o = append(o, 0xa6, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74)
		o = msgp.AppendInt(o, z.Video.Height)
	}
	// string "site_name"
	o = append(o, 0xa9, 0x73, 0x69, 0x74, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.SiteName)
	// string "icon_url"
	o = append(o, 0xa8, 0x69, 0x63, 0x6f, 0x6e, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.IconURL)
	// string "colour"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
	o = msgp.AppendString(o, z.Colour)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEmbed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		case "original_url":
			z.OriginalURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OriginalURL")
				return
			}
		case "special":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Special = nil
			} else {
				if z.Special == nil {
					z.Special = new(MessageEmbedSpecial)
				}
				bts, err = z.Special.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Special")
					return
				}
			}
		case "title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "image":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Image = nil
			} else {
				if z.Image == nil {
					z.Image = new(MessageEmbedImage)
				}
				bts, err = z.Image.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Image")
					return
				}
			}
		case "video":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Video = nil
			} else {
				if z.Video == nil {
					z.Video = new(MessageEmbedVideo)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Video")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Video")
						return
					}
					switch msgp.UnsafeString(field) {
					case "url":
						z.Video.URL, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Video", "URL")
							return
						}
					case "width":
						z.Video.Width, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Video", "Width")
							return
						}
					case "height":
						z.Video.Height, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Video", "Height")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Video")
							return
						}
					}
				}
			}
		case "site_name":
			z.SiteName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SiteName")
				return
			}
		case "icon_url":
			z.IconURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IconURL")
				return
			}
		case "colour":
			z.Colour, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Colour")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageEmbed) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Type) + 4 + msgp.StringPrefixSize + len(z.URL) + 13 + msgp.StringPrefixSize + len(z.OriginalURL) + 8
	if z.Special == nil {
		s += msgp.NilSize
	} else {
		s += z.Special.Msgsize()
	}
	s += 6 + msgp.StringPrefixSize + len(z.Title) + 12 + msgp.StringPrefixSize + len(z.Description) + 6
	if z.Image == nil {
		s += msgp.NilSize
	} else {
		s += z.Image.Msgsize()
	}
	s += 6
	if z.Video == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 4 + msgp.StringPrefixSize + len(z.Video.URL) + 6 + msgp.IntSize + 7 + msgp.IntSize
	}
	s += 10 + msgp.StringPrefixSize + len(z.SiteName) + 9 + msgp.StringPrefixSize + len(z.IconURL) + 7 + msgp.StringPrefixSize + len(z.Colour)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageEmbedImage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "size"
	o = append(o, 0x84, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendString(o, z.Size)
	// string "url"
	o = append(o, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	// string "width"
	o = append(o, 0xa5, 0x77, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "height"
	o = append(o, 0xa6, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEmbedImage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "size":
			z.Size, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		case "width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageEmbedImage) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Size) + 4 + msgp.StringPrefixSize + len(z.URL) + 6 + msgp.IntSize + 7 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageEmbedSpecial) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "timestamp"
	o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "content_type"
	o = append(o, 0xac, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ContentType)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEmbedSpecial) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MessageEmbedSpecialType(zb0002)
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "content_type":
			z.ContentType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContentType")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageEmbedSpecial) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 3 + msgp.StringPrefixSize + len(z.ID) + 10 + z.Timestamp.Msgsize() + 13 + msgp.StringPrefixSize + len(z.ContentType)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageEmbedSpecialType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEmbedSpecialType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MessageEmbedSpecialType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageEmbedSpecialType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageEmbedVideo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "url"
	o = append(o, 0x83, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	// string "width"
	o = append(o, 0xa5, 0x77, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "height"
	o = append(o, 0xa6, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageEmbedVideo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		case "width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageEmbedVideo) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.URL) + 6 + msgp.IntSize + 7 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageFlagsType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint32(o, uint32(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageFlagsType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint32
		zb0001, bts, err = msgp.ReadUint32Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MessageFlagsType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageFlagsType) Msgsize() (s int) {
	s = msgp.Uint32Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageInteractions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "reactions"
	o = append(o, 0x82, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Reactions)))
	for za0001 := range z.Reactions {
		o = msgp.AppendString(o, z.Reactions[za0001])
	}
	// string "restrict_reactions"
	o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendBool(o, z.RestrictReactions)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageInteractions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "reactions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reactions")
				return
			}
			if cap(z.Reactions) >= int(zb0002) {
				z.Reactions = (z.Reactions)[:zb0002]
			} else {
				z.Reactions = make([]string, zb0002)
			}
			for za0001 := range z.Reactions {
				z.Reactions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions", za0001)
					return
				}
			}
		case "restrict_reactions":
			z.RestrictReactions, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RestrictReactions")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageInteractions) Msgsize() (s int) {
	s = 1 + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.Reactions {
		s += msgp.StringPrefixSize + len(z.Reactions[za0001])
	}
	s += 19 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageMasquerade) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "name"
	o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	o = msgp.AppendString(o, z.Avatar)
	// string "colour"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
	o = msgp.AppendString(o, z.Colour)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageMasquerade) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			z.Avatar, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avatar")
				return
			}
		case "colour":
			z.Colour, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Colour")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageMasquerade) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.StringPrefixSize + len(z.Avatar) + 7 + msgp.StringPrefixSize + len(z.Colour)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageReplies) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "mention"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendBool(o, z.Mention)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageReplies) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "mention":
			z.Mention, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mention")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageReplies) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageSend) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "content"
	o = append(o, 0x86, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "attachments"
	o = append(o, 0xab, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Attachments)))
	for za0001 := range z.Attachments {
		o = msgp.AppendString(o, z.Attachments[za0001])
	}
	// string "replies"
	o = append(o, 0xa7, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Replies)))
	for za0002 := range z.Replies {
		if z.Replies[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "id"
			o = append(o, 0x82, 0xa2, 0x69, 0x64)
			o = msgp.AppendString(o, z.Replies[za0002].ID)
			// string "mention"
			o = append(o, 0xa7, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e)
			o = msgp.AppendBool(o, z.Replies[za0002].Mention)
		}
	}
	// string "embeds"
	o = append(o, 0xa6, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Embeds)))
	for za0003 := range z.Embeds {
		if z.Embeds[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Embeds[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Embeds", za0003)
				return
			}
		}
	}
	// string "masquerade"
	o = append(o, 0xaa, 0x6d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65)
	if z.Masquerade == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "name"
		o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Masquerade.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Avatar)
		// string "colour"
		o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Colour)
	}
	// string "interactions"
	o = append(o, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if z.Interactions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "reactions"
		o = append(o, 0x82, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Interactions.Reactions)))
		for za0004 := range z.Interactions.Reactions {
			o = msgp.AppendString(o, z.Interactions.Reactions[za0004])
		}
		// string "restrict_reactions"
		o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendBool(o, z.Interactions.RestrictReactions)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageSend) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "attachments":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Attachments")
				return
			}
			if cap(z.Attachments) >= int(zb0002) {
				z.Attachments = (z.Attachments)[:zb0002]
			} else {
				z.Attachments = make([]string, zb0002)
			}
			for za0001 := range z.Attachments {
				z.Attachments[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Attachments", za0001)
					return
				}
			}
		case "replies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Replies")
				return
			}
			if cap(z.Replies) >= int(zb0003) {
				z.Replies = (z.Replies)[:zb0003]
			} else {
				z.Replies = make([]*MessageReplies, zb0003)
			}
			for za0002 := range z.Replies {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Replies[za0002] = nil
				} else {
					if z.Replies[za0002] == nil {
						z.Replies[za0002] = new(MessageReplies)
					}
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Replies", za0002)
						return
					}
					for zb0004 > 0 {
						zb0004--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Replies", za0002)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.Replies[za0002].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Replies", za0002, "ID")
								return
							}
						case "mention":
							z.Replies[za0002].Mention, bts, err = msgp.ReadBoolBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Replies", za0002, "Mention")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Replies", za0002)
								return
							}
						}
					}
				}
			}
		case "embeds":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Embeds")
				return
			}
			if cap(z.Embeds) >= int(zb0005) {
				z.Embeds = (z.Embeds)[:zb0005]
			} else {
				z.Embeds = make([]*MessageEmbed, zb0005)
			}
			for za0003 := range z.Embeds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Embeds[za0003] = nil
				} else {
					if z.Embeds[za0003] == nil {
						z.Embeds[za0003] = new(MessageEmbed)
					}
					bts, err = z.Embeds[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Embeds", za0003)
						return
					}
				}
			}
		case "masquerade":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Masquerade = nil
			} else {
				if z.Masquerade == nil {
					z.Masquerade = new(MessageMasquerade)
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Masquerade")
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Masquerade")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Masquerade.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Name")
							return
						}
					case "avatar":
						z.Masquerade.Avatar, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Avatar")
							return
						}
					case "colour":
						z.Masquerade.Colour, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Colour")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade")
							return
						}
					}
				}
			}
		case "interactions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Interactions = nil
			} else {
				if z.Interactions == nil {
					z.Interactions = new(MessageInteractions)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interactions")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Interactions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "reactions":
						var zb0008 uint32
						zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "Reactions")
							return
						}
						if cap(z.Interactions.Reactions) >= int(zb0008) {
							z.Interactions.Reactions = (z.Interactions.Reactions)[:zb0008]
						} else {
							z.Interactions.Reactions = make([]string, zb0008)
						}
						for za0004 := range z.Interactions.Reactions {
							z.Interactions.Reactions[za0004], bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Interactions", "Reactions", za0004)
								return
							}
						}
					case "restrict_reactions":
						z.Interactions.RestrictReactions, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "RestrictReactions")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageSend) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Content) + 12 + msgp.ArrayHeaderSize
	for za0001 := range z.Attachments {
		s += msgp.StringPrefixSize + len(z.Attachments[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Replies {
		if z.Replies[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.StringPrefixSize + len(z.Replies[za0002].ID) + 8 + msgp.BoolSize
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0003 := range z.Embeds {
		if z.Embeds[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += z.Embeds[za0003].Msgsize()
		}
	}
	s += 11
	if z.Masquerade == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Masquerade.Name) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Avatar) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Colour)
	}
	s += 13
	if z.Interactions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.ArrayHeaderSize
		for za0004 := range z.Interactions.Reactions {
			s += msgp.StringPrefixSize + len(z.Interactions.Reactions[za0004])
		}
		s += 19 + msgp.BoolSize
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageSystem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "id"
	o = append(o, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageSystem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MessageSystemType(zb0002)
			}
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageSystem) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 3 + msgp.StringPrefixSize + len(z.ID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MessageSystemType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageSystemType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MessageSystemType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MessageSystemType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MessageWebhook) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Avatar)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MessageWebhook) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(string)
				}
				*z.Avatar, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MessageWebhook) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Avatar)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MutualFriendsAndServersResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "users"
	o = append(o, 0x82, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0001 := range z.Users {
		o = msgp.AppendString(o, z.Users[za0001])
	}
	// string "servers"
	o = append(o, 0xa7, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Servers)))
	for za0002 := range z.Servers {
		o = msgp.AppendString(o, z.Servers[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MutualFriendsAndServersResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "users":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0002) {
				z.Users = (z.Users)[:zb0002]
			} else {
				z.Users = make([]string, zb0002)
			}
			for za0001 := range z.Users {
				z.Users[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Users", za0001)
					return
				}
			}
		case "servers":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Servers")
				return
			}
			if cap(z.Servers) >= int(zb0003) {
				z.Servers = (z.Servers)[:zb0003]
			} else {
				z.Servers = make([]string, zb0003)
			}
			for za0002 := range z.Servers {
				z.Servers[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Servers", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MutualFriendsAndServersResponse) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Users {
		s += msgp.StringPrefixSize + len(z.Users[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Servers {
		s += msgp.StringPrefixSize + len(z.Servers[za0002])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Onboarding) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "onboarding"
	o = append(o, 0x81, 0xaa, 0x6f, 0x6e, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67)
	o = msgp.AppendBool(o, z.Onboarding)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Onboarding) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "onboarding":
			z.Onboarding, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Onboarding")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Onboarding) Msgsize() (s int) {
	s = 1 + 11 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OnboardingCompleteData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "username"
	o = append(o, 0x81, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OnboardingCompleteData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OnboardingCompleteData) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Username)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialChannel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "name"
	o = append(o, 0x8b, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if z.Name == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Name)
	}
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	if z.Owner == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Owner)
	}
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if z.Description == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Description)
	}
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if z.Icon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Icon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Icon")
			return
		}
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	if z.NSFW == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.NSFW)
	}
	// string "active"
	o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
	if z.Active == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Active)
	}
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.Permissions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Permissions)
	}
	// string "role_permissions"
	o = append(o, 0xb0, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.RolePermissions)))
	for za0001, za0002 := range z.RolePermissions {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, za0002.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, za0002.Deny)
	}
	// string "default_permissions"
	o = append(o, 0xb3, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.DefaultPermissions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, z.DefaultPermissions.Deny)
	}
	// string "last_message_id"
	o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64)
	if z.LastMessageID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.LastMessageID)
	}
	// string "voice"
	o = append(o, 0xa5, 0x76, 0x6f, 0x69, 0x63, 0x65)
	if z.Voice == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "max_users"
		o = append(o, 0x81, 0xa9, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73)
		if z.Voice.MaxUsers == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Voice.MaxUsers)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialChannel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Name = nil
			} else {
				if z.Name == nil {
					z.Name = new(string)
				}
				*z.Name, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
			}
		case "owner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Owner = nil
			} else {
				if z.Owner == nil {
					z.Owner = new(string)
				}
				*z.Owner, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Owner")
					return
				}
			}
		case "description":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Description = nil
			} else {
				if z.Description == nil {
					z.Description = new(string)
				}
				*z.Description, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Description")
					return
				}
			}
		case "icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Icon = nil
			} else {
				if z.Icon == nil {
					z.Icon = new(Attachment)
				}
				bts, err = z.Icon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Icon")
					return
				}
			}
		case "nsfw":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.NSFW = nil
			} else {
				if z.NSFW == nil {
					z.NSFW = new(bool)
				}
				*z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NSFW")
					return
				}
			}
		case "active":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Active = nil
			} else {
				if z.Active == nil {
					z.Active = new(bool)
				}
				*z.Active, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
			}
		case "permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Permissions = nil
			} else {
				if z.Permissions == nil {
					z.Permissions = new(int64)
				}
				*z.Permissions, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
			}
		case "role_permissions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RolePermissions")
				return
			}
			if z.RolePermissions == nil {
				z.RolePermissions = make(map[string]PermissionOverwrite, zb0002)
			} else if len(z.RolePermissions) > 0 {
				clear(z.RolePermissions)
			}
			for zb0002 > 0 {
				var za0002 PermissionOverwrite
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RolePermissions", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "RolePermissions", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						za0002.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Allow")
							return
						}
					case "d":
						za0002.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001, "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "RolePermissions", za0001)
							return
						}
					}
				}
				z.RolePermissions[za0001] = za0002
			}
		case "default_permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DefaultPermissions = nil
			} else {
				if z.DefaultPermissions == nil {
					z.DefaultPermissions = new(PermissionOverwrite)
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DefaultPermissions")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "DefaultPermissions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						z.DefaultPermissions.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Allow")
							return
						}
					case "d":
						z.DefaultPermissions.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions", "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "DefaultPermissions")
							return
						}
					}
				}
			}
		case "last_message_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastMessageID = nil
			} else {
				if z.LastMessageID == nil {
					z.LastMessageID = new(string)
				}
				*z.LastMessageID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMessageID")
					return
				}
			}
		case "voice":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Voice = nil
			} else {
				if z.Voice == nil {
					z.Voice = new(ChannelVoiceInformation)
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Voice")
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Voice")
						return
					}
					switch msgp.UnsafeString(field) {
					case "max_users":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Voice.MaxUsers = nil
						} else {
							if z.Voice.MaxUsers == nil {
								z.Voice.MaxUsers = new(int)
							}
							*z.Voice.MaxUsers, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Voice", "MaxUsers")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Voice")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialChannel) Msgsize() (s int) {
	s = 1 + 5
	if z.Name == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Name)
	}
	s += 6
	if z.Owner == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Owner)
	}
	s += 12
	if z.Description == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Description)
	}
	s += 5
	if z.Icon == nil {
		s += msgp.NilSize
	} else {
		s += z.Icon.Msgsize()
	}
	s += 5
	if z.NSFW == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 7
	if z.Active == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 12
	if z.Permissions == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 17 + msgp.MapHeaderSize
	if z.RolePermissions != nil {
		for za0001, za0002 := range z.RolePermissions {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
		}
	}
	s += 20
	if z.DefaultPermissions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	}
	s += 16
	if z.LastMessageID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LastMessageID)
	}
	s += 6
	if z.Voice == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10
		if z.Voice.MaxUsers == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialServer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "owner"
	o = append(o, 0x8e, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	if z.Owner == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Owner)
	}
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if z.Name == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Name)
	}
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if z.Description == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Description)
	}
	// string "channels"
	o = append(o, 0xa8, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	if z.Channels == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.Channels)))
		for za0001 := range *z.Channels {
			o = msgp.AppendString(o, (*z.Channels)[za0001])
		}
	}
	// string "categories"
	o = append(o, 0xaa, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73)
	if z.Categories == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.Categories)))
		for za0002 := range *z.Categories {
			if (*z.Categories)[za0002] == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = (*z.Categories)[za0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Categories", za0002)
					return
				}
			}
		}
	}
	// string "system_messages"
	o = append(o, 0xaf, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
	if z.SystemMessages == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.SystemMessages.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SystemMessages")
			return
		}
	}
	// string "roles"
	o = append(o, 0xa5, 0x72, 0x6f, 0x6c, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Roles)))
	for za0003, za0004 := range z.Roles {
		o = msgp.AppendString(o, za0003)
		if za0004 == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = za0004.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Roles", za0003)
				return
			}
		}
	}
	// string "default_permissions"
	o = append(o, 0xb3, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.DefaultPermissions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.DefaultPermissions)
	}
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if z.Icon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Icon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Icon")
			return
		}
	}
	// string "banner"
	o = append(o, 0xa6, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	if z.Banner == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Banner.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Banner")
			return
		}
	}
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if z.Flags == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendUint32(o, *z.Flags)
	}
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	if z.NSFW == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.NSFW)
	}
	// string "analytics"
	o = append(o, 0xa9, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73)
	if z.Analytics == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Analytics)
	}
	// string "discoverable"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	if z.Discoverable == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Discoverable)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialServer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "owner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Owner = nil
			} else {
				if z.Owner == nil {
					z.Owner = new(string)
				}
				*z.Owner, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Owner")
					return
				}
			}
		case "name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Name = nil
			} else {
				if z.Name == nil {
					z.Name = new(string)
				}
				*z.Name, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
			}
		case "description":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Description = nil
			} else {
				if z.Description == nil {
					z.Description = new(string)
				}
				*z.Description, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Description")
					return
				}
			}
		case "channels":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Channels = nil
			} else {
				if z.Channels == nil {
					z.Channels = new([]string)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Channels")
					return
				}
				if cap(*z.Channels) >= int(zb0002) {
					*z.Channels = (*z.Channels)[:zb0002]
				} else {
					*z.Channels = make([]string, zb0002)
				}
				for za0001 := range *z.Channels {
					(*z.Channels)[za0001], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Channels", za0001)
						return
					}
				}
			}
		case "categories":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Categories = nil
			} else {
				if z.Categories == nil {
					z.Categories = new([]*ServerCategory)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Categories")
					return
				}
				if cap(*z.Categories) >= int(zb0003) {
					*z.Categories = (*z.Categories)[:zb0003]
				} else {
					*z.Categories = make([]*ServerCategory, zb0003)
				}
				for za0002 := range *z.Categories {
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						(*z.Categories)[za0002] = nil
					} else {
						if (*z.Categories)[za0002] == nil {
							(*z.Categories)[za0002] = new(ServerCategory)
						}
						bts, err = (*z.Categories)[za0002].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Categories", za0002)
							return
						}
					}
				}
			}
		case "system_messages":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SystemMessages = nil
			} else {
				if z.SystemMessages == nil {
					z.SystemMessages = new(ServerSystemMessages)
				}
				bts, err = z.SystemMessages.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SystemMessages")
					return
				}
			}
		case "roles":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Roles")
				return
			}
			if z.Roles == nil {
				z.Roles = make(map[string]*ServerRole, zb0004)
			} else if len(z.Roles) > 0 {
				clear(z.Roles)
			}
			for zb0004 > 0 {
				var za0004 *ServerRole
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Roles")
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					za0004 = nil
				} else {
					if za0004 == nil {
						za0004 = new(ServerRole)
					}
					bts, err = za0004.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Roles", za0003)
						return
					}
				}
				z.Roles[za0003] = za0004
			}
		case "default_permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DefaultPermissions = nil
			} else {
				if z.DefaultPermissions == nil {
					z.DefaultPermissions = new(int64)
				}
				*z.DefaultPermissions, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DefaultPermissions")
					return
				}
			}
		case "icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Icon = nil
			} else {
				if z.Icon == nil {
					z.Icon = new(Attachment)
				}
				bts, err = z.Icon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Icon")
					return
				}
			}
		case "banner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Banner = nil
			} else {
				if z.Banner == nil {
					z.Banner = new(Attachment)
				}
				bts, err = z.Banner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Banner")
					return
				}
			}
		case "flags":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Flags = nil
			} else {
				if z.Flags == nil {
					z.Flags = new(uint32)
				}
				*z.Flags, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
			}
		case "nsfw":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.NSFW = nil
			} else {
				if z.NSFW == nil {
					z.NSFW = new(bool)
				}
				*z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NSFW")
					return
				}
			}
		case "analytics":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Analytics = nil
			} else {
				if z.Analytics == nil {
					z.Analytics = new(bool)
				}
				*z.Analytics, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Analytics")
					return
				}
			}
		case "discoverable":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Discoverable = nil
			} else {
				if z.Discoverable == nil {
					z.Discoverable = new(bool)
				}
				*z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Discoverable")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialServer) Msgsize() (s int) {
	s = 1 + 6
	if z.Owner == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Owner)
	}
	s += 5
	if z.Name == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Name)
	}
	s += 12
	if z.Description == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Description)
	}
	s += 9
	if z.Channels == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for za0001 := range *z.Channels {
			s += msgp.StringPrefixSize + len((*z.Channels)[za0001])
		}
	}
	s += 11
	if z.Categories == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for za0002 := range *z.Categories {
			if (*z.Categories)[za0002] == nil {
				s += msgp.NilSize
			} else {
				s += (*z.Categories)[za0002].Msgsize()
			}
		}
	}
	s += 16
	if z.SystemMessages == nil {
		s += msgp.NilSize
	} else {
		s += z.SystemMessages.Msgsize()
	}
	s += 6 + msgp.MapHeaderSize
	if z.Roles != nil {
		for za0003, za0004 := range z.Roles {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003)
			if za0004 == nil {
				s += msgp.NilSize
			} else {
				s += za0004.Msgsize()
			}
		}
	}
	s += 20
	if z.DefaultPermissions == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 5
	if z.Icon == nil {
		s += msgp.NilSize
	} else {
		s += z.Icon.Msgsize()
	}
	s += 7
	if z.Banner == nil {
		s += msgp.NilSize
	} else {
		s += z.Banner.Msgsize()
	}
	s += 6
	if z.Flags == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Uint32Size
	}
	s += 5
	if z.NSFW == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 10
	if z.Analytics == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 13
	if z.Discoverable == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialServerMember) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "nickname"
	o = append(o, 0x86, 0xa8, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65)
	if z.Nickname == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Nickname)
	}
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "roles"
	o = append(o, 0xa5, 0x72, 0x6f, 0x6c, 0x65, 0x73)
	if z.Roles == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.Roles)))
		for za0001 := range *z.Roles {
			o = msgp.AppendString(o, (*z.Roles)[za0001])
		}
	}
	// string "timeout"
	o = append(o, 0xa7, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
	o, err = z.Timeout.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timeout")
		return
	}
	// string "can_publish"
	o = append(o, 0xab, 0x63, 0x61, 0x6e, 0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68)
	if z.CanPublish == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.CanPublish)
	}
	// string "can_receive"
	o = append(o, 0xab, 0x63, 0x61, 0x6e, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65)
	if z.CanReceive == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.CanReceive)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialServerMember) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nickname":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Nickname = nil
			} else {
				if z.Nickname == nil {
					z.Nickname = new(string)
				}
				*z.Nickname, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nickname")
					return
				}
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "roles":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Roles = nil
			} else {
				if z.Roles == nil {
					z.Roles = new([]string)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Roles")
					return
				}
				if cap(*z.Roles) >= int(zb0002) {
					*z.Roles = (*z.Roles)[:zb0002]
				} else {
					*z.Roles = make([]string, zb0002)
				}
				for za0001 := range *z.Roles {
					(*z.Roles)[za0001], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Roles", za0001)
						return
					}
				}
			}
		case "timeout":
			bts, err = z.Timeout.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timeout")
				return
			}
		case "can_publish":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CanPublish = nil
			} else {
				if z.CanPublish == nil {
					z.CanPublish = new(bool)
				}
				*z.CanPublish, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CanPublish")
					return
				}
			}
		case "can_receive":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CanReceive = nil
			} else {
				if z.CanReceive == nil {
					z.CanReceive = new(bool)
				}
				*z.CanReceive, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CanReceive")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialServerMember) Msgsize() (s int) {
	s = 1 + 9
	if z.Nickname == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Nickname)
	}
	s += 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 6
	if z.Roles == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for za0001 := range *z.Roles {
			s += msgp.StringPrefixSize + len((*z.Roles)[za0001])
		}
	}
	s += 8 + z.Timeout.Msgsize() + 12
	if z.CanPublish == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 12
	if z.CanReceive == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialServerRole) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if z.Name == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Name)
	}
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.Permissions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o = msgp.AppendInt64(o, z.Permissions.Allow)
		// string "d"
		o = append(o, 0xa1, 0x64)
		o = msgp.AppendInt64(o, z.Permissions.Deny)
	}
	// string "colour"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
	if z.Colour == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Colour)
	}
	// string "hoist"
	o = append(o, 0xa5, 0x68, 0x6f, 0x69, 0x73, 0x74)
	if z.Hoist == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Hoist)
	}
	// string "rank"
	o = append(o, 0xa4, 0x72, 0x61, 0x6e, 0x6b)
	if z.Rank == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Rank)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialServerRole) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Name = nil
			} else {
				if z.Name == nil {
					z.Name = new(string)
				}
				*z.Name, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
			}
		case "permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Permissions = nil
			} else {
				if z.Permissions == nil {
					z.Permissions = new(PermissionOverwrite)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Permissions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						z.Permissions.Allow, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Permissions", "Allow")
							return
						}
					case "d":
						z.Permissions.Deny, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Permissions", "Deny")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Permissions")
							return
						}
					}
				}
			}
		case "colour":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Colour = nil
			} else {
				if z.Colour == nil {
					z.Colour = new(string)
				}
				*z.Colour, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Colour")
					return
				}
			}
		case "hoist":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Hoist = nil
			} else {
				if z.Hoist == nil {
					z.Hoist = new(bool)
				}
				*z.Hoist, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hoist")
					return
				}
			}
		case "rank":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Rank = nil
			} else {
				if z.Rank == nil {
					z.Rank = new(int64)
				}
				*z.Rank, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Rank")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialServerRole) Msgsize() (s int) {
	s = 1 + 5
	if z.Name == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Name)
	}
	s += 12
	if z.Permissions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	}
	s += 7
	if z.Colour == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Colour)
	}
	s += 6
	if z.Hoist == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 5
	if z.Rank == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialUser) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "_id"
	o = append(o, 0x8e, 0xa3, 0x5f, 0x69, 0x64)
	if z.ID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.ID)
	}
	// string "username"
	o = append(o, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if z.Username == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Username)
	}
	// string "discriminator"
	o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72)
	if z.Discriminator == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Discriminator)
	}
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if z.Flags == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendUint32(o, *z.Flags)
	}
	// string "privileged"
	o = append(o, 0xaa, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64)
	if z.Privileged == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Privileged)
	}
	// string "badges"
	o = append(o, 0xa6, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73)
	if z.Badges == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendUint32(o, *z.Badges)
	}
	// string "online"
	o = append(o, 0xa6, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
	if z.Online == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Online)
	}
	// string "relations"
	o = append(o, 0xa9, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if z.Relations == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.Relations)))
		for za0001 := range *z.Relations {
			// map header, size 2
			// string "_id"
			o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
			o = msgp.AppendString(o, (*z.Relations)[za0001].ID)
			// string "status"
			o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, string((*z.Relations)[za0001].Status))
		}
	}
	// string "relationship"
	o = append(o, 0xac, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70)
	if z.Relationship == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, string(*z.Relationship))
	}
	// string "display_name"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if z.DisplayName == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.DisplayName)
	}
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if z.Status == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "text"
		o = append(o, 0x82, 0xa4, 0x74, 0x65, 0x78, 0x74)
		o = msgp.AppendString(o, z.Status.Text)
		// string "presence"
		o = append(o, 0xa8, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63, 0x65)
		o = msgp.AppendString(o, string(z.Status.Presence))
	}
	// string "profile"
	o = append(o, 0xa7, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65)
	if z.Profile == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "content"
		o = append(o, 0x82, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Profile.Content)
		// string "background"
		o = append(o, 0xaa, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64)
		if z.Profile.Background == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Profile.Background.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Profile", "Background")
				return
			}
		}
	}
	// string "bot"
	o = append(o, 0xa3, 0x62, 0x6f, 0x74)
	if z.Bot == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Bot.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bot")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialUser) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ID = nil
			} else {
				if z.ID == nil {
					z.ID = new(string)
				}
				*z.ID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
			}
		case "username":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Username = nil
			} else {
				if z.Username == nil {
					z.Username = new(string)
				}
				*z.Username, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Username")
					return
				}
			}
		case "discriminator":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Discriminator = nil
			} else {
				if z.Discriminator == nil {
					z.Discriminator = new(string)
				}
				*z.Discriminator, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Discriminator")
					return
				}
			}
		case "flags":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Flags = nil
			} else {
				if z.Flags == nil {
					z.Flags = new(uint32)
				}
				*z.Flags, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
			}
		case "privileged":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Privileged = nil
			} else {
				if z.Privileged == nil {
					z.Privileged = new(bool)
				}
				*z.Privileged, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Privileged")
					return
				}
			}
		case "badges":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Badges = nil
			} else {
				if z.Badges == nil {
					z.Badges = new(uint32)
				}
				*z.Badges, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Badges")
					return
				}
			}
		case "online":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Online = nil
			} else {
				if z.Online == nil {
					z.Online = new(bool)
				}
				*z.Online, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Online")
					return
				}
			}
		case "relations":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Relations = nil
			} else {
				if z.Relations == nil {
					z.Relations = new([]UserRelationship)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Relations")
					return
				}
				if cap(*z.Relations) >= int(zb0002) {
					*z.Relations = (*z.Relations)[:zb0002]
				} else {
					*z.Relations = make([]UserRelationship, zb0002)
				}
				for za0001 := range *z.Relations {
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Relations", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Relations", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "_id":
							(*z.Relations)[za0001].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Relations", za0001, "ID")
								return
							}
						case "status":
							{
								var zb0004 string
								zb0004, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Relations", za0001, "Status")
									return
								}
								(*z.Relations)[za0001].Status = UserRelationshipType(zb0004)
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Relations", za0001)
								return
							}
						}
					}
				}
			}
		case "relationship":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Relationship = nil
			} else {
				if z.Relationship == nil {
					z.Relationship = new(UserRelationshipType)
				}
				{
					var zb0005 string
					zb0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Relationship")
						return
					}
					*z.Relationship = UserRelationshipType(zb0005)
				}
			}
		case "display_name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayName = nil
			} else {
				if z.DisplayName == nil {
					z.DisplayName = new(string)
				}
				*z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayName")
					return
				}
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "status":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Status = nil
			} else {
				if z.Status == nil {
					z.Status = new(UserStatus)
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
					switch msgp.UnsafeString(field) {
					case "text":
						z.Status.Text, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status", "Text")
							return
						}
					case "presence":
						{
							var zb0007 string
							zb0007, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Status", "Presence")
								return
							}
							z.Status.Presence = UserStatusPresence(zb0007)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status")
							return
						}
					}
				}
			}
		case "profile":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Profile = nil
			} else {
				if z.Profile == nil {
					z.Profile = new(UserProfile)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Profile")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Profile")
						return
					}
					switch msgp.UnsafeString(field) {
					case "content":
						z.Profile.Content, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile", "Content")
							return
						}
					case "background":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Profile.Background = nil
						} else {
							if z.Profile.Background == nil {
								z.Profile.Background = new(Attachment)
							}
							bts, err = z.Profile.Background.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Profile", "Background")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile")
							return
						}
					}
				}
			}
		case "bot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Bot = nil
			} else {
				if z.Bot == nil {
					z.Bot = new(Bot)
				}
				bts, err = z.Bot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bot")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialUser) Msgsize() (s int) {
	s = 1 + 4
	if z.ID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.ID)
	}
	s += 9
	if z.Username == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Username)
	}
	s += 14
	if z.Discriminator == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Discriminator)
	}
	s += 6
	if z.Flags == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Uint32Size
	}
	s += 11
	if z.Privileged == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 7
	if z.Badges == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Uint32Size
	}
	s += 7
	if z.Online == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 10
	if z.Relations == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for za0001 := range *z.Relations {
			s += 1 + 4 + msgp.StringPrefixSize + len((*z.Relations)[za0001].ID) + 7 + msgp.StringPrefixSize + len(string((*z.Relations)[za0001].Status))
		}
	}
	s += 13
	if z.Relationship == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Relationship))
	}
	s += 13
	if z.DisplayName == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.DisplayName)
	}
	s += 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 7
	if z.Status == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Status.Text) + 9 + msgp.StringPrefixSize + len(string(z.Status.Presence))
	}
	s += 8
	if z.Profile == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8 + msgp.StringPrefixSize + len(z.Profile.Content) + 11
		if z.Profile.Background == nil {
			s += msgp.NilSize
		} else {
			s += z.Profile.Background.Msgsize()
		}
	}
	s += 4
	if z.Bot == nil {
		s += msgp.NilSize
	} else {
		s += z.Bot.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialUserVoiceState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "_id"
	o = append(o, 0x86, 0xa3, 0x5f, 0x69, 0x64)
	if z.ID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.ID)
	}
	// string "joined_at"
	o = append(o, 0xa9, 0x6a, 0x6f, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x61, 0x74)
	o, err = z.JoinedAt.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "JoinedAt")
		return
	}
	// string "is_receiving"
	o = append(o, 0xac, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67)
	if z.IsReceiving == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.IsReceiving)
	}
	// string "is_publishing"
	o = append(o, 0xad, 0x69, 0x73, 0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68, 0x69, 0x6e, 0x67)
	if z.IsPublishing == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.IsPublishing)
	}
	// string "screensharing"
	o = append(o, 0xad, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x61, 0x72, 0x69, 0x6e, 0x67)
	if z.Screensharing == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Screensharing)
	}
	// string "camera"
	o = append(o, 0xa6, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61)
	if z.Camera == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Camera)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialUserVoiceState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ID = nil
			} else {
				if z.ID == nil {
					z.ID = new(string)
				}
				*z.ID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
			}
		case "joined_at":
			bts, err = z.JoinedAt.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "JoinedAt")
				return
			}
		case "is_receiving":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.IsReceiving = nil
			} else {
				if z.IsReceiving == nil {
					z.IsReceiving = new(bool)
				}
				*z.IsReceiving, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IsReceiving")
					return
				}
			}
		case "is_publishing":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.IsPublishing = nil
			} else {
				if z.IsPublishing == nil {
					z.IsPublishing = new(bool)
				}
				*z.IsPublishing, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IsPublishing")
					return
				}
			}
		case "screensharing":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Screensharing = nil
			} else {
				if z.Screensharing == nil {
					z.Screensharing = new(bool)
				}
				*z.Screensharing, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Screensharing")
					return
				}
			}
		case "camera":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Camera = nil
			} else {
				if z.Camera == nil {
					z.Camera = new(bool)
				}
				*z.Camera, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Camera")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialUserVoiceState) Msgsize() (s int) {
	s = 1 + 4
	if z.ID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.ID)
	}
	s += 10 + z.JoinedAt.Msgsize() + 13
	if z.IsReceiving == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 14
	if z.IsPublishing == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 14
	if z.Screensharing == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 7
	if z.Camera == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PartialWebhook) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "name"
	o = append(o, 0x86, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if z.Name == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Name)
	}
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "creator_id"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64)
	if z.CreatorID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.CreatorID)
	}
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	if z.ChannelID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.ChannelID)
	}
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if z.Permissions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendUint64(o, *z.Permissions)
	}
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if z.Token == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Token)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PartialWebhook) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Name = nil
			} else {
				if z.Name == nil {
					z.Name = new(string)
				}
				*z.Name, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "creator_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CreatorID = nil
			} else {
				if z.CreatorID == nil {
					z.CreatorID = new(string)
				}
				*z.CreatorID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CreatorID")
					return
				}
			}
		case "channel_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ChannelID = nil
			} else {
				if z.ChannelID == nil {
					z.ChannelID = new(string)
				}
				*z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChannelID")
					return
				}
			}
		case "permissions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Permissions = nil
			} else {
				if z.Permissions == nil {
					z.Permissions = new(uint64)
				}
				*z.Permissions, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
			}
		case "token":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Token = nil
			} else {
				if z.Token == nil {
					z.Token = new(string)
				}
				*z.Token, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Token")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PartialWebhook) Msgsize() (s int) {
	s = 1 + 5
	if z.Name == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Name)
	}
	s += 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 11
	if z.CreatorID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.CreatorID)
	}
	s += 11
	if z.ChannelID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.ChannelID)
	}
	s += 12
	if z.Permissions == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Uint64Size
	}
	s += 6
	if z.Token == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Token)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PasswordResetConfirmData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "token"
	o = append(o, 0x83, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	// string "password"
	o = append(o, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	// string "remove_sessions"
	o = append(o, 0xaf, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendBool(o, z.RemoveSessions)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PasswordResetConfirmData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		case "remove_sessions":
			z.RemoveSessions, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RemoveSessions")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PasswordResetConfirmData) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Token) + 9 + msgp.StringPrefixSize + len(z.Password) + 16 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PermissionOverwrite) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "a"
	o = append(o, 0x82, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.Allow)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt64(o, z.Deny)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PermissionOverwrite) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			z.Allow, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Allow")
				return
			}
		case "d":
			z.Deny, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Deny")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PermissionOverwrite) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PermissionsSetDefaultData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "permissions"
	o = append(o, 0x81, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendUint(o, z.Permissions)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PermissionsSetDefaultData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "permissions":
			z.Permissions, bts, err = msgp.ReadUintBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PermissionsSetDefaultData) Msgsize() (s int) {
	s = 1 + 12 + msgp.UintSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PolicyChange) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "created_time"
	o = append(o, 0x84, 0xac, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendString(o, z.CreatedTime)
	// string "effective_time"
	o = append(o, 0xae, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendString(o, z.EffectiveTime)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "url"
	o = append(o, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PolicyChange) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "created_time":
			z.CreatedTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedTime")
				return
			}
		case "effective_time":
			z.EffectiveTime, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EffectiveTime")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PolicyChange) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.CreatedTime) + 15 + msgp.StringPrefixSize + len(z.EffectiveTime) + 12 + msgp.StringPrefixSize + len(z.Description) + 4 + msgp.StringPrefixSize + len(z.URL)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PublicBot) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "_id"
	o = append(o, 0x84, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "username"
	o = append(o, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PublicBot) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PublicBot) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 9 + msgp.StringPrefixSize + len(z.Username) + 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 12 + msgp.StringPrefixSize + len(z.Description)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Server) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 15
	// string "_id"
	o = append(o, 0x8f, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "owner"
	o = append(o, 0xa5, 0x6f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "channels"
	o = append(o, 0xa8, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Channels)))
	for za0001 := range z.Channels {
		o = msgp.AppendString(o, z.Channels[za0001])
	}
	// string "categories"
	o = append(o, 0xaa, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Categories)))
	for za0002 := range z.Categories {
		if z.Categories[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Categories[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Categories", za0002)
				return
			}
		}
	}
	// string "system_messages"
	o = append(o, 0xaf, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
	o, err = z.SystemMessages.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "SystemMessages")
		return
	}
	// string "roles"
	o = append(o, 0xa5, 0x72, 0x6f, 0x6c, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Roles)))
	for za0003, za0004 := range z.Roles {
		o = msgp.AppendString(o, za0003)
		if za0004 == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = za0004.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Roles", za0003)
				return
			}
		}
	}
	// string "default_permissions"
	o = append(o, 0xb3, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendInt64(o, z.DefaultPermissions)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.Flags)
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	// string "analytics"
	o = append(o, 0xa9, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73)
	o = msgp.AppendBool(o, z.Analytics)
	// string "discoverable"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Discoverable)
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if z.Icon == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Icon.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Icon")
			return
		}
	}
	// string "banner"
	o = append(o, 0xa6, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	if z.Banner == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Banner.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Banner")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Server) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "channels":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
			if cap(z.Channels) >= int(zb0002) {
				z.Channels = (z.Channels)[:zb0002]
			} else {
				z.Channels = make([]string, zb0002)
			}
			for za0001 := range z.Channels {
				z.Channels[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Channels", za0001)
					return
				}
			}
		case "categories":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Categories")
				return
			}
			if cap(z.Categories) >= int(zb0003) {
				z.Categories = (z.Categories)[:zb0003]
			} else {
				z.Categories = make([]*ServerCategory, zb0003)
			}
			for za0002 := range z.Categories {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Categories[za0002] = nil
				} else {
					if z.Categories[za0002] == nil {
						z.Categories[za0002] = new(ServerCategory)
					}
					bts, err = z.Categories[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Categories", za0002)
						return
					}
				}
			}
		case "system_messages":
			bts, err = z.SystemMessages.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "SystemMessages")
				return
			}
		case "roles":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Roles")
				return
			}
			if z.Roles == nil {
				z.Roles = make(map[string]*ServerRole, zb0004)
			} else if len(z.Roles) > 0 {
				clear(z.Roles)
			}
			for zb0004 > 0 {
				var za0004 *ServerRole
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Roles")
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					za0004 = nil
				} else {
					if za0004 == nil {
						za0004 = new(ServerRole)
					}
					bts, err = za0004.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Roles", za0003)
						return
					}
				}
				z.Roles[za0003] = za0004
			}
		case "default_permissions":
			z.DefaultPermissions, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DefaultPermissions")
				return
			}
		case "flags":
			z.Flags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		case "analytics":
			z.Analytics, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Analytics")
				return
			}
		case "discoverable":
			z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Discoverable")
				return
			}
		case "icon":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Icon = nil
			} else {
				if z.Icon == nil {
					z.Icon = new(Attachment)
				}
				bts, err = z.Icon.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Icon")
					return
				}
			}
		case "banner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Banner = nil
			} else {
				if z.Banner == nil {
					z.Banner = new(Attachment)
				}
				bts, err = z.Banner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Banner")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Server) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Owner) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Channels {
		s += msgp.StringPrefixSize + len(z.Channels[za0001])
	}
	s += 11 + msgp.ArrayHeaderSize
	for za0002 := range z.Categories {
		if z.Categories[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Categories[za0002].Msgsize()
		}
	}
	s += 16 + z.SystemMessages.Msgsize() + 6 + msgp.MapHeaderSize
	if z.Roles != nil {
		for za0003, za0004 := range z.Roles {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003)
			if za0004 == nil {
				s += msgp.NilSize
			} else {
				s += za0004.Msgsize()
			}
		}
	}
	s += 20 + msgp.Int64Size + 6 + msgp.Uint32Size + 5 + msgp.BoolSize + 10 + msgp.BoolSize + 13 + msgp.BoolSize + 5
	if z.Icon == nil {
		s += msgp.NilSize
	} else {
		s += z.Icon.Msgsize()
	}
	s += 7
	if z.Banner == nil {
		s += msgp.NilSize
	} else {
		s += z.Banner.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerBan) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "_id"
	o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
	// map header, size 2
	// string "user"
	o = append(o, 0x82, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.User)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.Server)
	// string "reason"
	o = append(o, 0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Reason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerBan) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				switch msgp.UnsafeString(field) {
				case "user":
					z.ID.User, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "User")
						return
					}
				case "server":
					z.ID.Server, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "Server")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID")
						return
					}
				}
			}
		case "reason":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerBan) Msgsize() (s int) {
	s = 1 + 4 + 1 + 5 + msgp.StringPrefixSize + len(z.ID.User) + 7 + msgp.StringPrefixSize + len(z.ID.Server) + 7 + msgp.StringPrefixSize + len(z.Reason)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerBans) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "users"
	o = append(o, 0x82, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0001 := range z.Users {
		if z.Users[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0001)
				return
			}
		}
	}
	// string "bans"
	o = append(o, 0xa4, 0x62, 0x61, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bans)))
	for za0002 := range z.Bans {
		if z.Bans[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bans[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Bans", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerBans) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "users":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0002) {
				z.Users = (z.Users)[:zb0002]
			} else {
				z.Users = make([]*User, zb0002)
			}
			for za0001 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0001] = nil
				} else {
					if z.Users[za0001] == nil {
						z.Users[za0001] = new(User)
					}
					bts, err = z.Users[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0001)
						return
					}
				}
			}
		case "bans":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bans")
				return
			}
			if cap(z.Bans) >= int(zb0003) {
				z.Bans = (z.Bans)[:zb0003]
			} else {
				z.Bans = make([]*ServerBan, zb0003)
			}
			for za0002 := range z.Bans {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Bans[za0002] = nil
				} else {
					if z.Bans[za0002] == nil {
						z.Bans[za0002] = new(ServerBan)
					}
					bts, err = z.Bans[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Bans", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerBans) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Users {
		if z.Users[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0001].Msgsize()
		}
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0002 := range z.Bans {
		if z.Bans[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Bans[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerCategory) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "title"
	o = append(o, 0xa5, 0x74, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "channels"
	o = append(o, 0xa8, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Channels)))
	for za0001 := range z.Channels {
		o = msgp.AppendString(o, z.Channels[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerCategory) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "channels":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
			if cap(z.Channels) >= int(zb0002) {
				z.Channels = (z.Channels)[:zb0002]
			} else {
				z.Channels = make([]string, zb0002)
			}
			for za0001 := range z.Channels {
				z.Channels[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Channels", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerCategory) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Title) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Channels {
		s += msgp.StringPrefixSize + len(z.Channels[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerChannelCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "type"
	o = append(o, 0x84, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "nsfw"
	o = append(o, 0xa4, 0x6e, 0x73, 0x66, 0x77)
	o = msgp.AppendBool(o, z.NSFW)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerChannelCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = ServerChannelCreateDataType(zb0002)
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "nsfw":
			z.NSFW, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NSFW")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerChannelCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 5 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ServerChannelCreateDataType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerChannelCreateDataType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ServerChannelCreateDataType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ServerChannelCreateDataType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ServerCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ServerCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "name"
	o = append(o, 0x8a, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	// string "banner"
	o = append(o, 0xa6, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Banner)
	// string "categories"
	o = append(o, 0xaa, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Categories)))
	for za0001 := range z.Categories {
		if z.Categories[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Categories[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Categories", za0001)
				return
			}
		}
	}
	// string "system_messages"
	o = append(o, 0xaf, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
	if z.SystemMessages == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.SystemMessages.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SystemMessages")
			return
		}
	}
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendInt(o, z.Flags)
	// string "discoverable"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65)
	if z.Discoverable == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Discoverable)
	}
	// string "analytics"
	o = append(o, 0xa9, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73)
	if z.Analytics == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Analytics)
	}
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0002 := range z.Remove {
		o = msgp.AppendString(o, string(z.Remove[za0002]))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "banner":
			z.Banner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Banner")
				return
			}
		case "categories":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Categories")
				return
			}
			if cap(z.Categories) >= int(zb0002) {
				z.Categories = (z.Categories)[:zb0002]
			} else {
				z.Categories = make([]*ServerCategory, zb0002)
			}
			for za0001 := range z.Categories {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Categories[za0001] = nil
				} else {
					if z.Categories[za0001] == nil {
						z.Categories[za0001] = new(ServerCategory)
					}
					bts, err = z.Categories[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Categories", za0001)
						return
					}
				}
			}
		case "system_messages":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SystemMessages = nil
			} else {
				if z.SystemMessages == nil {
					z.SystemMessages = new(ServerSystemMessages)
				}
				bts, err = z.SystemMessages.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SystemMessages")
					return
				}
			}
		case "flags":
			z.Flags, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		case "discoverable":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Discoverable = nil
			} else {
				if z.Discoverable == nil {
					z.Discoverable = new(bool)
				}
				*z.Discoverable, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Discoverable")
					return
				}
			}
		case "analytics":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Analytics = nil
			} else {
				if z.Analytics == nil {
					z.Analytics = new(bool)
				}
				*z.Analytics, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Analytics")
					return
				}
			}
		case "remove":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0003) {
				z.Remove = (z.Remove)[:zb0003]
			} else {
				z.Remove = make([]ServerEditDataRemove, zb0003)
			}
			for za0002 := range z.Remove {
				{
					var zb0004 string
					zb0004, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Remove", za0002)
						return
					}
					z.Remove[za0002] = ServerEditDataRemove(zb0004)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerEditData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 5 + msgp.StringPrefixSize + len(z.Icon) + 7 + msgp.StringPrefixSize + len(z.Banner) + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.Categories {
		if z.Categories[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Categories[za0001].Msgsize()
		}
	}
	s += 16
	if z.SystemMessages == nil {
		s += msgp.NilSize
	} else {
		s += z.SystemMessages.Msgsize()
	}
	s += 6 + msgp.IntSize + 13
	if z.Discoverable == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 10
	if z.Analytics == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Remove {
		s += msgp.StringPrefixSize + len(string(z.Remove[za0002]))
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ServerEditDataRemove) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerEditDataRemove) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ServerEditDataRemove(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ServerEditDataRemove) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerMember) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "_id"
	o = append(o, 0x88, 0xa3, 0x5f, 0x69, 0x64)
	// map header, size 2
	// string "user"
	o = append(o, 0x82, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.User)
	// string "server"
	o = append(o, 0xa6, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.Server)
	// string "joined_at"
	o = append(o, 0xa9, 0x6a, 0x6f, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x61, 0x74)
	o, err = z.JoinedAt.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "JoinedAt")
		return
	}
	// string "nickname"
	o = append(o, 0xa8, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65)
	if z.Nickname == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Nickname)
	}
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "timeout"
	o = append(o, 0xa7, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
	o, err = z.Timeout.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timeout")
		return
	}
	// string "roles"
	o = append(o, 0xa5, 0x72, 0x6f, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Roles)))
	for za0001 := range z.Roles {
		o = msgp.AppendString(o, z.Roles[za0001])
	}
	// string "can_publish"
	o = append(o, 0xab, 0x63, 0x61, 0x6e, 0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68)
	o = msgp.AppendBool(o, z.CanPublish)
	// string "can_receive"
	o = append(o, 0xab, 0x63, 0x61, 0x6e, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65)
	o = msgp.AppendBool(o, z.CanReceive)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerMember) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				switch msgp.UnsafeString(field) {
				case "user":
					z.ID.User, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "User")
						return
					}
				case "server":
					z.ID.Server, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "Server")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID")
						return
					}
				}
			}
		case "joined_at":
			bts, err = z.JoinedAt.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "JoinedAt")
				return
			}
		case "nickname":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Nickname = nil
			} else {
				if z.Nickname == nil {
					z.Nickname = new(string)
				}
				*z.Nickname, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nickname")
					return
				}
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "timeout":
			bts, err = z.Timeout.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timeout")
				return
			}
		case "roles":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Roles")
				return
			}
			if cap(z.Roles) >= int(zb0003) {
				z.Roles = (z.Roles)[:zb0003]
			} else {
				z.Roles = make([]string, zb0003)
			}
			for za0001 := range z.Roles {
				z.Roles[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Roles", za0001)
					return
				}
			}
		case "can_publish":
			z.CanPublish, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanPublish")
				return
			}
		case "can_receive":
			z.CanReceive, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanReceive")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerMember) Msgsize() (s int) {
	s = 1 + 4 + 1 + 5 + msgp.StringPrefixSize + len(z.ID.User) + 7 + msgp.StringPrefixSize + len(z.ID.Server) + 10 + z.JoinedAt.Msgsize() + 9
	if z.Nickname == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Nickname)
	}
	s += 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 8 + z.Timeout.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Roles {
		s += msgp.StringPrefixSize + len(z.Roles[za0001])
	}
	s += 12 + msgp.BoolSize + 12 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerMemberEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "nickname"
	o = append(o, 0x85, 0xa8, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Nickname)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	o = msgp.AppendString(o, z.Avatar)
	// string "roles"
	o = append(o, 0xa5, 0x72, 0x6f, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Roles)))
	for za0001 := range z.Roles {
		o = msgp.AppendString(o, z.Roles[za0001])
	}
	// string "timeout"
	o = append(o, 0xa7, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
	o = msgp.AppendTime(o, z.Timeout)
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0002 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerMemberEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nickname":
			z.Nickname, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nickname")
				return
			}
		case "avatar":
			z.Avatar, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avatar")
				return
			}
		case "roles":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Roles")
				return
			}
			if cap(z.Roles) >= int(zb0002) {
				z.Roles = (z.Roles)[:zb0002]
			} else {
				z.Roles = make([]string, zb0002)
			}
			for za0001 := range z.Roles {
				z.Roles[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Roles", za0001)
					return
				}
			}
		case "timeout":
			z.Timeout, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timeout")
				return
			}
		case "remove":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0003) {
				z.Remove = (z.Remove)[:zb0003]
			} else {
				z.Remove = make([]string, zb0003)
			}
			for za0002 := range z.Remove {
				z.Remove[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerMemberEditData) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Nickname) + 7 + msgp.StringPrefixSize + len(z.Avatar) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Roles {
		s += msgp.StringPrefixSize + len(z.Roles[za0001])
	}
	s += 8 + msgp.TimeSize + 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0002])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerMembers) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "members"
	o = append(o, 0x82, 0xa7, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Members)))
	for za0001 := range z.Members {
		if z.Members[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Members[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Members", za0001)
				return
			}
		}
	}
	// string "users"
	o = append(o, 0xa5, 0x75, 0x73, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Users)))
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Users[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Users", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerMembers) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "members":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Members")
				return
			}
			if cap(z.Members) >= int(zb0002) {
				z.Members = (z.Members)[:zb0002]
			} else {
				z.Members = make([]*ServerMember, zb0002)
			}
			for za0001 := range z.Members {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Members[za0001] = nil
				} else {
					if z.Members[za0001] == nil {
						z.Members[za0001] = new(ServerMember)
					}
					bts, err = z.Members[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Members", za0001)
						return
					}
				}
			}
		case "users":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Users")
				return
			}
			if cap(z.Users) >= int(zb0003) {
				z.Users = (z.Users)[:zb0003]
			} else {
				z.Users = make([]*User, zb0003)
			}
			for za0002 := range z.Users {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Users[za0002] = nil
				} else {
					if z.Users[za0002] == nil {
						z.Users[za0002] = new(User)
					}
					bts, err = z.Users[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Users", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerMembers) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Members {
		if z.Members[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Members[za0001].Msgsize()
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Users {
		if z.Users[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Users[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerRole) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	// map header, size 2
	// string "a"
	o = append(o, 0x82, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.Permissions.Allow)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt64(o, z.Permissions.Deny)
	// string "colour"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
	if z.Colour == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Colour)
	}
	// string "hoist"
	o = append(o, 0xa5, 0x68, 0x6f, 0x69, 0x73, 0x74)
	o = msgp.AppendBool(o, z.Hoist)
	// string "rank"
	o = append(o, 0xa4, 0x72, 0x61, 0x6e, 0x6b)
	o = msgp.AppendInt64(o, z.Rank)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerRole) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "permissions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Permissions")
					return
				}
				switch msgp.UnsafeString(field) {
				case "a":
					z.Permissions.Allow, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Permissions", "Allow")
						return
					}
				case "d":
					z.Permissions.Deny, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Permissions", "Deny")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Permissions")
						return
					}
				}
			}
		case "colour":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Colour = nil
			} else {
				if z.Colour == nil {
					z.Colour = new(string)
				}
				*z.Colour, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Colour")
					return
				}
			}
		case "hoist":
			z.Hoist, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hoist")
				return
			}
		case "rank":
			z.Rank, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rank")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerRole) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size + 7
	if z.Colour == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Colour)
	}
	s += 6 + msgp.BoolSize + 5 + msgp.Int64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ServerRoleCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "rank"
	o = append(o, 0xa4, 0x72, 0x61, 0x6e, 0x6b)
	o = msgp.AppendInt(o, z.Rank)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerRoleCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "rank":
			z.Rank, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rank")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ServerRoleCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerRoleEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "colour"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
	o = msgp.AppendString(o, z.Colour)
	// string "hoist"
	o = append(o, 0xa5, 0x68, 0x6f, 0x69, 0x73, 0x74)
	if z.Hoist == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.Hoist)
	}
	// string "rank"
	o = append(o, 0xa4, 0x72, 0x61, 0x6e, 0x6b)
	if z.Rank == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Rank)
	}
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerRoleEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "colour":
			z.Colour, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Colour")
				return
			}
		case "hoist":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Hoist = nil
			} else {
				if z.Hoist == nil {
					z.Hoist = new(bool)
				}
				*z.Hoist, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hoist")
					return
				}
			}
		case "rank":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Rank = nil
			} else {
				if z.Rank == nil {
					z.Rank = new(int)
				}
				*z.Rank, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Rank")
					return
				}
			}
		case "remove":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0002) {
				z.Remove = (z.Remove)[:zb0002]
			} else {
				z.Remove = make([]string, zb0002)
			}
			for za0001 := range z.Remove {
				z.Remove[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerRoleEditData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.StringPrefixSize + len(z.Colour) + 6
	if z.Hoist == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 5
	if z.Rank == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerSystemMessages) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "user_joined"
	o = append(o, 0x84, 0xab, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6a, 0x6f, 0x69, 0x6e, 0x65, 0x64)
	o = msgp.AppendString(o, z.UserJoined)
	// string "user_left"
	o = append(o, 0xa9, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6c, 0x65, 0x66, 0x74)
	o = msgp.AppendString(o, z.UserLeft)
	// string "user_kicked"
	o = append(o, 0xab, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6b, 0x69, 0x63, 0x6b, 0x65, 0x64)
	o = msgp.AppendString(o, z.UserKicked)
	// string "user_banned"
	o = append(o, 0xab, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendString(o, z.UserBanned)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerSystemMessages) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "user_joined":
			z.UserJoined, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserJoined")
				return
			}
		case "user_left":
			z.UserLeft, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserLeft")
				return
			}
		case "user_kicked":
			z.UserKicked, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserKicked")
				return
			}
		case "user_banned":
			z.UserBanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UserBanned")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerSystemMessages) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.UserJoined) + 10 + msgp.StringPrefixSize + len(z.UserLeft) + 12 + msgp.StringPrefixSize + len(z.UserKicked) + 12 + msgp.StringPrefixSize + len(z.UserBanned)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SessionEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "friendly_name"
	o = append(o, 0x81, 0xad, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x6c, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.FriendlyName)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SessionEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "friendly_name":
			z.FriendlyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FriendlyName")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SessionEditData) Msgsize() (s int) {
	s = 1 + 14 + msgp.StringPrefixSize + len(z.FriendlyName)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Sessions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "_id"
	o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Sessions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Sessions) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyncSettingsData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for za0001, za0002 := range z {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "0"
		o = append(o, 0x82, 0xa1, 0x30)
		o = msgp.AppendTime(o, za0002.Timestamp)
		// string "1"
		o = append(o, 0xa1, 0x31)
		o, err = za0002.Value.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, za0001, "Value")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncSettingsData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(SyncSettingsData, zb0003)
	} else if len((*z)) > 0 {
		clear((*z))
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0002 SyncSettingsDataTuple
		zb0003--
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "0":
				zb0002.Timestamp, bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Timestamp")
					return
				}
			case "1":
				bts, err = zb0002.Value.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Value")
					return
				}
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyncSettingsData) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0005, zb0006 := range z {
			_ = zb0006
			s += msgp.StringPrefixSize + len(zb0005) + 1 + 2 + msgp.TimeSize + 2 + zb0006.Value.Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SyncSettingsDataTuple) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "0"
	o = append(o, 0x82, 0xa1, 0x30)
	o = msgp.AppendTime(o, z.Timestamp)
	// string "1"
	o = append(o, 0xa1, 0x31)
	o, err = z.Value.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Value")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncSettingsDataTuple) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "0":
			z.Timestamp, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "1":
			bts, err = z.Value.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Value")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SyncSettingsDataTuple) Msgsize() (s int) {
	s = 1 + 2 + msgp.TimeSize + 2 + z.Value.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SyncSettingsFetchData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "keys"
	o = append(o, 0x81, 0xa4, 0x6b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Keys)))
	for za0001 := range z.Keys {
		o = msgp.AppendString(o, z.Keys[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncSettingsFetchData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "keys":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Keys")
				return
			}
			if cap(z.Keys) >= int(zb0002) {
				z.Keys = (z.Keys)[:zb0002]
			} else {
				z.Keys = make([]string, zb0002)
			}
			for za0001 := range z.Keys {
				z.Keys[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Keys", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SyncSettingsFetchData) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize
	for za0001 := range z.Keys {
		s += msgp.StringPrefixSize + len(z.Keys[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SyncUnread) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "_id"
	o = append(o, 0x83, 0xa3, 0x5f, 0x69, 0x64)
	// map header, size 2
	// string "channel"
	o = append(o, 0x82, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.ID.Channel)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.ID.User)
	// string "last_id"
	o = append(o, 0xa7, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.LastID)
	// string "mentions"
	o = append(o, 0xa8, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Mentions)))
	for za0001 := range z.Mentions {
		o = msgp.AppendString(o, z.Mentions[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyncUnread) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				switch msgp.UnsafeString(field) {
				case "channel":
					z.ID.Channel, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "Channel")
						return
					}
				case "user":
					z.ID.User, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID", "User")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ID")
						return
					}
				}
			}
		case "last_id":
			z.LastID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastID")
				return
			}
		case "mentions":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mentions")
				return
			}
			if cap(z.Mentions) >= int(zb0003) {
				z.Mentions = (z.Mentions)[:zb0003]
			} else {
				z.Mentions = make([]string, zb0003)
			}
			for za0001 := range z.Mentions {
				z.Mentions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mentions", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SyncUnread) Msgsize() (s int) {
	s = 1 + 4 + 1 + 8 + msgp.StringPrefixSize + len(z.ID.Channel) + 5 + msgp.StringPrefixSize + len(z.ID.User) + 8 + msgp.StringPrefixSize + len(z.LastID) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Mentions {
		s += msgp.StringPrefixSize + len(z.Mentions[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *User) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "_id"
	o = append(o, 0x8e, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "username"
	o = append(o, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	// string "discriminator"
	o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Discriminator)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, z.Flags)
	// string "privileged"
	o = append(o, 0xaa, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Privileged)
	// string "badges"
	o = append(o, 0xa6, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73)
	o = msgp.AppendUint32(o, z.Badges)
	// string "online"
	o = append(o, 0xa6, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendBool(o, z.Online)
	// string "relations"
	o = append(o, 0xa9, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Relations)))
	for za0001 := range z.Relations {
		// map header, size 2
		// string "_id"
		o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
		o = msgp.AppendString(o, z.Relations[za0001].ID)
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, string(z.Relations[za0001].Status))
	}
	// string "relationship"
	o = append(o, 0xac, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70)
	o = msgp.AppendString(o, string(z.Relationship))
	// string "display_name"
	o = append(o, 0xac, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if z.DisplayName == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.DisplayName)
	}
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if z.Status == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "text"
		o = append(o, 0x82, 0xa4, 0x74, 0x65, 0x78, 0x74)
		o = msgp.AppendString(o, z.Status.Text)
		// string "presence"
		o = append(o, 0xa8, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63, 0x65)
		o = msgp.AppendString(o, string(z.Status.Presence))
	}
	// string "profile"
	o = append(o, 0xa7, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65)
	if z.Profile == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "content"
		o = append(o, 0x82, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Profile.Content)
		// string "background"
		o = append(o, 0xaa, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64)
		if z.Profile.Background == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Profile.Background.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Profile", "Background")
				return
			}
		}
	}
	// string "bot"
	o = append(o, 0xa3, 0x62, 0x6f, 0x74)
	if z.Bot == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Bot.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bot")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *User) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "discriminator":
			z.Discriminator, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Discriminator")
				return
			}
		case "flags":
			z.Flags, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
		case "privileged":
			z.Privileged, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Privileged")
				return
			}
		case "badges":
			z.Badges, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Badges")
				return
			}
		case "online":
			z.Online, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Online")
				return
			}
		case "relations":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Relations")
				return
			}
			if cap(z.Relations) >= int(zb0002) {
				z.Relations = (z.Relations)[:zb0002]
			} else {
				z.Relations = make([]UserRelationship, zb0002)
			}
			for za0001 := range z.Relations {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Relations", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Relations", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "_id":
						z.Relations[za0001].ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Relations", za0001, "ID")
							return
						}
					case "status":
						{
							var zb0004 string
							zb0004, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Relations", za0001, "Status")
								return
							}
							z.Relations[za0001].Status = UserRelationshipType(zb0004)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Relations", za0001)
							return
						}
					}
				}
			}
		case "relationship":
			{
				var zb0005 string
				zb0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Relationship")
					return
				}
				z.Relationship = UserRelationshipType(zb0005)
			}
		case "display_name":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayName = nil
			} else {
				if z.DisplayName == nil {
					z.DisplayName = new(string)
				}
				*z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayName")
					return
				}
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "status":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Status = nil
			} else {
				if z.Status == nil {
					z.Status = new(UserStatus)
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
					switch msgp.UnsafeString(field) {
					case "text":
						z.Status.Text, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status", "Text")
							return
						}
					case "presence":
						{
							var zb0007 string
							zb0007, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Status", "Presence")
								return
							}
							z.Status.Presence = UserStatusPresence(zb0007)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status")
							return
						}
					}
				}
			}
		case "profile":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Profile = nil
			} else {
				if z.Profile == nil {
					z.Profile = new(UserProfile)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Profile")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Profile")
						return
					}
					switch msgp.UnsafeString(field) {
					case "content":
						z.Profile.Content, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile", "Content")
							return
						}
					case "background":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Profile.Background = nil
						} else {
							if z.Profile.Background == nil {
								z.Profile.Background = new(Attachment)
							}
							bts, err = z.Profile.Background.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Profile", "Background")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile")
							return
						}
					}
				}
			}
		case "bot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Bot = nil
			} else {
				if z.Bot == nil {
					z.Bot = new(Bot)
				}
				bts, err = z.Bot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bot")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *User) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 9 + msgp.StringPrefixSize + len(z.Username) + 14 + msgp.StringPrefixSize + len(z.Discriminator) + 6 + msgp.Uint32Size + 11 + msgp.BoolSize + 7 + msgp.Uint32Size + 7 + msgp.BoolSize + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.Relations {
		s += 1 + 4 + msgp.StringPrefixSize + len(z.Relations[za0001].ID) + 7 + msgp.StringPrefixSize + len(string(z.Relations[za0001].Status))
	}
	s += 13 + msgp.StringPrefixSize + len(string(z.Relationship)) + 13
	if z.DisplayName == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.DisplayName)
	}
	s += 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 7
	if z.Status == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Status.Text) + 9 + msgp.StringPrefixSize + len(string(z.Status.Presence))
	}
	s += 8
	if z.Profile == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8 + msgp.StringPrefixSize + len(z.Profile.Content) + 11
		if z.Profile.Background == nil {
			s += msgp.NilSize
		} else {
			s += z.Profile.Background.Msgsize()
		}
	}
	s += 4
	if z.Bot == nil {
		s += msgp.NilSize
	} else {
		s += z.Bot.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "display_name"
	o = append(o, 0x87, 0xac, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DisplayName)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	o = msgp.AppendString(o, z.Avatar)
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if z.Status == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "text"
		o = append(o, 0x82, 0xa4, 0x74, 0x65, 0x78, 0x74)
		o = msgp.AppendString(o, z.Status.Text)
		// string "presence"
		o = append(o, 0xa8, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63, 0x65)
		o = msgp.AppendString(o, string(z.Status.Presence))
	}
	// string "profile"
	o = append(o, 0xa7, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65)
	if z.Profile == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "content"
		o = append(o, 0x82, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Profile.Content)
		// string "background"
		o = append(o, 0xaa, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64)
		if z.Profile.Background == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Profile.Background.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Profile", "Background")
				return
			}
		}
	}
	// string "badges"
	o = append(o, 0xa6, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73)
	if z.Badges == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Badges)
	}
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	if z.Flags == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Flags)
	}
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, z.Remove[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "display_name":
			z.DisplayName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayName")
				return
			}
		case "avatar":
			z.Avatar, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avatar")
				return
			}
		case "status":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Status = nil
			} else {
				if z.Status == nil {
					z.Status = new(UserStatus)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Status")
						return
					}
					switch msgp.UnsafeString(field) {
					case "text":
						z.Status.Text, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status", "Text")
							return
						}
					case "presence":
						{
							var zb0003 string
							zb0003, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Status", "Presence")
								return
							}
							z.Status.Presence = UserStatusPresence(zb0003)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Status")
							return
						}
					}
				}
			}
		case "profile":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Profile = nil
			} else {
				if z.Profile == nil {
					z.Profile = new(UserProfile)
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Profile")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Profile")
						return
					}
					switch msgp.UnsafeString(field) {
					case "content":
						z.Profile.Content, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile", "Content")
							return
						}
					case "background":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Profile.Background = nil
						} else {
							if z.Profile.Background == nil {
								z.Profile.Background = new(Attachment)
							}
							bts, err = z.Profile.Background.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Profile", "Background")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Profile")
							return
						}
					}
				}
			}
		case "badges":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Badges = nil
			} else {
				if z.Badges == nil {
					z.Badges = new(int)
				}
				*z.Badges, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Badges")
					return
				}
			}
		case "flags":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Flags = nil
			} else {
				if z.Flags == nil {
					z.Flags = new(int)
				}
				*z.Flags, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
			}
		case "remove":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0005) {
				z.Remove = (z.Remove)[:zb0005]
			} else {
				z.Remove = make([]string, zb0005)
			}
			for za0001 := range z.Remove {
				z.Remove[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Remove", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserEditData) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.DisplayName) + 7 + msgp.StringPrefixSize + len(z.Avatar) + 7
	if z.Status == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Status.Text) + 9 + msgp.StringPrefixSize + len(string(z.Status.Presence))
	}
	s += 8
	if z.Profile == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8 + msgp.StringPrefixSize + len(z.Profile.Content) + 11
		if z.Profile.Background == nil {
			s += msgp.NilSize
		} else {
			s += z.Profile.Background.Msgsize()
		}
	}
	s += 7
	if z.Badges == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 6
	if z.Flags == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(z.Remove[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserProfile) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "content"
	o = append(o, 0x82, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "background"
	o = append(o, 0xaa, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64)
	if z.Background == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Background.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Background")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserProfile) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "background":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Background = nil
			} else {
				if z.Background == nil {
					z.Background = new(Attachment)
				}
				bts, err = z.Background.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Background")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserProfile) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Content) + 11
	if z.Background == nil {
		s += msgp.NilSize
	} else {
		s += z.Background.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserRelationship) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "_id"
	o = append(o, 0x82, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, string(z.Status))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserRelationship) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "status":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				z.Status = UserRelationshipType(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserRelationship) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 7 + msgp.StringPrefixSize + len(string(z.Status))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserRelationshipType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserRelationshipType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserRelationshipType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserRelationshipType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserSettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Updated"
	o = append(o, 0x82, 0xa7, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendInt(o, z.Updated)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserSettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Updated":
			z.Updated, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Updated")
				return
			}
		case "Data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserSettings) Msgsize() (s int) {
	s = 1 + 8 + msgp.IntSize + 5 + z.Data.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "text"
	o = append(o, 0x82, 0xa4, 0x74, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.Text)
	// string "presence"
	o = append(o, 0xa8, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63, 0x65)
	o = msgp.AppendString(o, string(z.Presence))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "text":
			z.Text, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Text")
				return
			}
		case "presence":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Presence")
					return
				}
				z.Presence = UserStatusPresence(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserStatus) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Text) + 9 + msgp.StringPrefixSize + len(string(z.Presence))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserStatusPresence) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserStatusPresence) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserStatusPresence(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserStatusPresence) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserVoiceState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "_id"
	o = append(o, 0x86, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "joined_at"
	o = append(o, 0xa9, 0x6a, 0x6f, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x61, 0x74)
	o, err = z.JoinedAt.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "JoinedAt")
		return
	}
	// string "is_receiving"
	o = append(o, 0xac, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67)
	o = msgp.AppendBool(o, z.IsReceiving)
	// string "is_publishing"
	o = append(o, 0xad, 0x69, 0x73, 0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x73, 0x68, 0x69, 0x6e, 0x67)
	o = msgp.AppendBool(o, z.IsPublishing)
	// string "screensharing"
	o = append(o, 0xad, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x61, 0x72, 0x69, 0x6e, 0x67)
	o = msgp.AppendBool(o, z.Screensharing)
	// string "camera"
	o = append(o, 0xa6, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61)
	o = msgp.AppendBool(o, z.Camera)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserVoiceState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "joined_at":
			bts, err = z.JoinedAt.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "JoinedAt")
				return
			}
		case "is_receiving":
			z.IsReceiving, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsReceiving")
				return
			}
		case "is_publishing":
			z.IsPublishing, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsPublishing")
				return
			}
		case "screensharing":
			z.Screensharing, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Screensharing")
				return
			}
		case "camera":
			z.Camera, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Camera")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserVoiceState) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 10 + z.JoinedAt.Msgsize() + 13 + msgp.BoolSize + 14 + msgp.BoolSize + 14 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UsernameData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "username"
	o = append(o, 0x82, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Username)
	// string "password"
	o = append(o, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UsernameData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "username":
			z.Username, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Username")
				return
			}
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UsernameData) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Username) + 9 + msgp.StringPrefixSize + len(z.Password)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Webhook) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "_id"
	o = append(o, 0x87, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	if z.Avatar == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Avatar.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Avatar")
			return
		}
	}
	// string "creator_id"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.CreatorID)
	// string "channel_id"
	o = append(o, 0xaa, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ChannelID)
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendUint64(o, z.Permissions)
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if z.Token == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.Token)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Webhook) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Avatar = nil
			} else {
				if z.Avatar == nil {
					z.Avatar = new(Attachment)
				}
				bts, err = z.Avatar.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avatar")
					return
				}
			}
		case "creator_id":
			z.CreatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatorID")
				return
			}
		case "channel_id":
			z.ChannelID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChannelID")
				return
			}
		case "permissions":
			z.Permissions, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		case "token":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Token = nil
			} else {
				if z.Token == nil {
					z.Token = new(string)
				}
				*z.Token, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Token")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Webhook) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name) + 7
	if z.Avatar == nil {
		s += msgp.NilSize
	} else {
		s += z.Avatar.Msgsize()
	}
	s += 11 + msgp.StringPrefixSize + len(z.CreatorID) + 11 + msgp.StringPrefixSize + len(z.ChannelID) + 12 + msgp.Uint64Size + 6
	if z.Token == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Token)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebhookCreateData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	o = msgp.AppendString(o, z.Avatar)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebhookCreateData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			z.Avatar, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avatar")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebhookCreateData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.StringPrefixSize + len(z.Avatar)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WebhookEditData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "name"
	o = append(o, 0x84, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "avatar"
	o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
	o = msgp.AppendString(o, z.Avatar)
	// string "permissions"
	o = append(o, 0xab, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendString(o, z.Permissions)
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Remove)))
	for za0001 := range z.Remove {
		o = msgp.AppendString(o, string(z.Remove[za0001]))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebhookEditData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "avatar":
			z.Avatar, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avatar")
				return
			}
		case "permissions":
			z.Permissions, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Permissions")
				return
			}
		case "remove":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
			if cap(z.Remove) >= int(zb0002) {
				z.Remove = (z.Remove)[:zb0002]
			} else {
				z.Remove = make([]WebhookRemoveField, zb0002)
			}
			for za0001 := range z.Remove {
				{
					var zb0003 string
					zb0003, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Remove", za0001)
						return
					}
					z.Remove[za0001] = WebhookRemoveField(zb0003)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WebhookEditData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.StringPrefixSize + len(z.Avatar) + 12 + msgp.StringPrefixSize + len(z.Permissions) + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Remove {
		s += msgp.StringPrefixSize + len(string(z.Remove[za0001]))
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WebhookExecuteData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "_id"
	o = append(o, 0xde, 0x0, 0x11, 0xa3, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "nonce"
	o = append(o, 0xa5, 0x6e, 0x6f, 0x6e, 0x63, 0x65)
	o = msgp.AppendString(o, z.Nonce)
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	// string "author"
	o = append(o, 0xa6, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Author)
	// string "content"
	o = append(o, 0xa7, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Content)
	// string "mentions"
	o = append(o, 0xa8, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Mentions)))
	for za0001 := range z.Mentions {
		o = msgp.AppendString(o, z.Mentions[za0001])
	}
	// string "replies"
	o = append(o, 0xa7, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Replies)))
	for za0002 := range z.Replies {
		o = msgp.AppendString(o, z.Replies[za0002])
	}
	// string "reactions"
	o = append(o, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Reactions)))
	for za0003, za0004 := range z.Reactions {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendArrayHeader(o, uint32(len(za0004)))
		for za0005 := range za0004 {
			o = msgp.AppendString(o, za0004[za0005])
		}
	}
	// string "pinned"
	o = append(o, 0xa6, 0x70, 0x69, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Pinned)
	// string "flags"
	o = append(o, 0xa5, 0x66, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint32(o, uint32(z.Flags))
	// string "webhook"
	o = append(o, 0xa7, 0x77, 0x65, 0x62, 0x68, 0x6f, 0x6f, 0x6b)
	if z.Webhook == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "name"
		o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Webhook.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		if z.Webhook.Avatar == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Webhook.Avatar)
		}
	}
	// string "system"
	o = append(o, 0xa6, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	if z.System == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "type"
		o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, string(z.System.Type))
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendString(o, z.System.ID)
	}
	// string "embeds"
	o = append(o, 0xa6, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Embeds)))
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Embeds[za0006].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Embeds", za0006)
				return
			}
		}
	}
	// string "attachments"
	o = append(o, 0xab, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Attachments)))
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Attachments[za0007].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Attachments", za0007)
				return
			}
		}
	}
	// string "edited"
	o = append(o, 0xa6, 0x65, 0x64, 0x69, 0x74, 0x65, 0x64)
	if z.Edited == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendTime(o, *z.Edited)
	}
	// string "interactions"
	o = append(o, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if z.Interactions == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "reactions"
		o = append(o, 0x82, 0xa9, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Interactions.Reactions)))
		for za0008 := range z.Interactions.Reactions {
			o = msgp.AppendString(o, z.Interactions.Reactions[za0008])
		}
		// string "restrict_reactions"
		o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendBool(o, z.Interactions.RestrictReactions)
	}
	// string "masquerade"
	o = append(o, 0xaa, 0x6d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65)
	if z.Masquerade == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "name"
		o = append(o, 0x83, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Masquerade.Name)
		// string "avatar"
		o = append(o, 0xa6, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Avatar)
		// string "colour"
		o = append(o, 0xa6, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72)
		o = msgp.AppendString(o, z.Masquerade.Colour)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebhookExecuteData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "_id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "nonce":
			z.Nonce, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nonce")
				return
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		case "author":
			z.Author, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Author")
				return
			}
		case "content":
			z.Content, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Content")
				return
			}
		case "mentions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mentions")
				return
			}
			if cap(z.Mentions) >= int(zb0002) {
				z.Mentions = (z.Mentions)[:zb0002]
			} else {
				z.Mentions = make([]string, zb0002)
			}
			for za0001 := range z.Mentions {
				z.Mentions[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mentions", za0001)
					return
				}
			}
		case "replies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Replies")
				return
			}
			if cap(z.Replies) >= int(zb0003) {
				z.Replies = (z.Replies)[:zb0003]
			} else {
				z.Replies = make([]string, zb0003)
			}
			for za0002 := range z.Replies {
				z.Replies[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replies", za0002)
					return
				}
			}
		case "reactions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reactions")
				return
			}
			if z.Reactions == nil {
				z.Reactions = make(map[string][]string, zb0004)
			} else if len(z.Reactions) > 0 {
				clear(z.Reactions)
			}
			for zb0004 > 0 {
				var za0004 []string
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions")
					return
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reactions", za0003)
					return
				}
				if cap(za0004) >= int(zb0005) {
					za0004 = (za0004)[:zb0005]
				} else {
					za0004 = make([]string, zb0005)
				}
				for za0005 := range za0004 {
					za0004[za0005], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reactions", za0003, za0005)
						return
					}
				}
				z.Reactions[za0003] = za0004
			}
		case "pinned":
			z.Pinned, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pinned")
				return
			}
		case "flags":
			{
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
				z.Flags = MessageFlagsType(zb0006)
			}
		case "webhook":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Webhook = nil
			} else {
				if z.Webhook == nil {
					z.Webhook = new(MessageWebhook)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Webhook")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Webhook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Webhook.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook", "Name")
							return
						}
					case "avatar":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Webhook.Avatar = nil
						} else {
							if z.Webhook.Avatar == nil {
								z.Webhook.Avatar = new(string)
							}
							*z.Webhook.Avatar, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Webhook", "Avatar")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Webhook")
							return
						}
					}
				}
			}
		case "system":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.System = nil
			} else {
				if z.System == nil {
					z.System = new(MessageSystem)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "System")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "System")
						return
					}
					switch msgp.UnsafeString(field) {
					case "type":
						{
							var zb0009 string
							zb0009, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "System", "Type")
								return
							}
							z.System.Type = MessageSystemType(zb0009)
						}
					case "id":
						z.System.ID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "System", "ID")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "System")
							return
						}
					}
				}
			}
		case "embeds":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Embeds")
				return
			}
			if cap(z.Embeds) >= int(zb0010) {
				z.Embeds = (z.Embeds)[:zb0010]
			} else {
				z.Embeds = make([]*MessageEmbed, zb0010)
			}
			for za0006 := range z.Embeds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Embeds[za0006] = nil
				} else {
					if z.Embeds[za0006] == nil {
						z.Embeds[za0006] = new(MessageEmbed)
					}
					bts, err = z.Embeds[za0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Embeds", za0006)
						return
					}
				}
			}
		case "attachments":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Attachments")
				return
			}
			if cap(z.Attachments) >= int(zb0011) {
				z.Attachments = (z.Attachments)[:zb0011]
			} else {
				z.Attachments = make([]*Attachment, zb0011)
			}
			for za0007 := range z.Attachments {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Attachments[za0007] = nil
				} else {
					if z.Attachments[za0007] == nil {
						z.Attachments[za0007] = new(Attachment)
					}
					bts, err = z.Attachments[za0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Attachments", za0007)
						return
					}
				}
			}
		case "edited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Edited = nil
			} else {
				if z.Edited == nil {
					z.Edited = new(time.Time)
				}
				*z.Edited, bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Edited")
					return
				}
			}
		case "interactions":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Interactions = nil
			} else {
				if z.Interactions == nil {
					z.Interactions = new(MessageInteractions)
				}
				var zb0012 uint32
				zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interactions")
					return
				}
				for zb0012 > 0 {
					zb0012--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Interactions")
						return
					}
					switch msgp.UnsafeString(field) {
					case "reactions":
						var zb0013 uint32
						zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "Reactions")
							return
						}
						if cap(z.Interactions.Reactions) >= int(zb0013) {
							z.Interactions.Reactions = (z.Interactions.Reactions)[:zb0013]
						} else {
							z.Interactions.Reactions = make([]string, zb0013)
						}
						for za0008 := range z.Interactions.Reactions {
							z.Interactions.Reactions[za0008], bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Interactions", "Reactions", za0008)
								return
							}
						}
					case "restrict_reactions":
						z.Interactions.RestrictReactions, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions", "RestrictReactions")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interactions")
							return
						}
					}
				}
			}
		case "masquerade":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Masquerade = nil
			} else {
				if z.Masquerade == nil {
					z.Masquerade = new(MessageMasquerade)
				}
				var zb0014 uint32
				zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Masquerade")
					return
				}
				for zb0014 > 0 {
					zb0014--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Masquerade")
						return
					}
					switch msgp.UnsafeString(field) {
					case "name":
						z.Masquerade.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Name")
							return
						}
					case "avatar":
						z.Masquerade.Avatar, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Avatar")
							return
						}
					case "colour":
						z.Masquerade.Colour, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade", "Colour")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Masquerade")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WebhookExecuteData) Msgsize() (s int) {
	s = 3 + 4 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Nonce) + 8 + msgp.StringPrefixSize + len(z.Channel) + 7 + msgp.StringPrefixSize + len(z.Author) + 8 + msgp.StringPrefixSize + len(z.Content) + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Mentions {
		s += msgp.StringPrefixSize + len(z.Mentions[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Replies {
		s += msgp.StringPrefixSize + len(z.Replies[za0002])
	}
	s += 10 + msgp.MapHeaderSize
	if z.Reactions != nil {
		for za0003, za0004 := range z.Reactions {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.ArrayHeaderSize
			for za0005 := range za0004 {
				s += msgp.StringPrefixSize + len(za0004[za0005])
			}
		}
	}
	s += 7 + msgp.BoolSize + 6 + msgp.Uint32Size + 8
	if z.Webhook == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Webhook.Name) + 7
		if z.Webhook.Avatar == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(*z.Webhook.Avatar)
		}
	}
	s += 7
	if z.System == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(string(z.System.Type)) + 3 + msgp.StringPrefixSize + len(z.System.ID)
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0006 := range z.Embeds {
		if z.Embeds[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += z.Embeds[za0006].Msgsize()
		}
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0007 := range z.Attachments {
		if z.Attachments[za0007] == nil {
			s += msgp.NilSize
		} else {
			s += z.Attachments[za0007].Msgsize()
		}
	}
	s += 7
	if z.Edited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13
	if z.Interactions == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.ArrayHeaderSize
		for za0008 := range z.Interactions.Reactions {
			s += msgp.StringPrefixSize + len(z.Interactions.Reactions[za0008])
		}
		s += 19 + msgp.BoolSize
	}
	s += 11
	if z.Masquerade == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Masquerade.Name) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Avatar) + 7 + msgp.StringPrefixSize + len(z.Masquerade.Colour)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebhookRemoveField) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebhookRemoveField) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = WebhookRemoveField(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebhookRemoveField) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebpushSubscription) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "endpoint"
	o = append(o, 0x83, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Endpoint)
	// string "p256dh"
	o = append(o, 0xa6, 0x70, 0x32, 0x35, 0x36, 0x64, 0x68)
	o = msgp.AppendString(o, z.P256DH)
	// string "auth"
	o = append(o, 0xa4, 0x61, 0x75, 0x74, 0x68)
	o = msgp.AppendString(o, z.Auth)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebpushSubscription) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "p256dh":
			z.P256DH, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "P256DH")
				return
			}
		case "auth":
			z.Auth, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebpushSubscription) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 7 + msgp.StringPrefixSize + len(z.P256DH) + 5 + msgp.StringPrefixSize + len(z.Auth)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebsocketChannelTyping) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "channel"
	o = append(o, 0xa7, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Channel)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebsocketChannelTyping) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = WebsocketMessageType(zb0002)
			}
		case "channel":
			z.Channel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channel")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebsocketChannelTyping) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 8 + msgp.StringPrefixSize + len(z.Channel)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebsocketMessageAuthenticate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "token"
	o = append(o, 0xa5, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.Token)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebsocketMessageAuthenticate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = WebsocketMessageType(zb0002)
			}
		case "token":
			z.Token, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Token")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebsocketMessageAuthenticate) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 6 + msgp.StringPrefixSize + len(z.Token)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebsocketMessagePing) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "type"
	o = append(o, 0x82, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	o = msgp.AppendInt64(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebsocketMessagePing) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = WebsocketMessageType(zb0002)
			}
		case "data":
			z.Data, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebsocketMessagePing) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 5 + msgp.Int64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WebsocketMessageType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WebsocketMessageType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = WebsocketMessageType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WebsocketMessageType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}
